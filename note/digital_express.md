数在计算机中的表示
================

<h2>真值</h2>

1.  含有正负号的数(能直观看出数的大小)
2.  如:

    $+1001$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ -1001 $

    $+0.1001$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ -0.1001 $
<hr>

<h2>原码</h2>

1.  不含有正负号,含有符号位，最高位作为符号位
2.  0表示正,1表示负
3.  对小数来说符号位后面就是小数点  
4.  如:

    <font color="red">$ 0 $ </font>$ ,1001 $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">$ 1$ </font>$ ,1001 $

    <font color="red">$ 0 $</font>$ .1001 $&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">$ 1 $</font>$ .1001 $

5.  原码可以反映出数的正负
6.  根据原码定义，0有两种 表示
    + 0,00000
    + 1,00000
7.  但是原码存在缺陷,在计算两个原码的时候,如下
    
    A 操作 B
    | 情况  | 操作数A | 操作数B | 操作  |                     结果                     |
    | :---: | :-----: | :-----: | :---: | :------------------------------------------: |
    |   1   |   >0    |   <0    |   -   |                      >0                      |
    |   2   |   <0    |   >0    |   -   |                      <0                      |
    |   3   |   >0    |   >0    |   -   | 需要进一步确定两个操作数的绝对值大小才能判断 |
    |   4   |   <0    |   <0    |   -   | 需要进一步确定两个操作数的绝对值大小才能判断 |

    *   由上述情况可知,计算机在计算3,4类型减法的时候，还必须比较操作数的绝对值的大小，这无疑增加了计算机的开销，而且计算机中有加法器，我们是否可以使用加法来计算这种减法呢?这样就无需额外的减法器以及绝对值比较了!

<hr>

<h2>补码</h2>

###  引例 ：从上面原码的例子中，我们可以看到计算机在计算时如果使用原码可能并没有那么容易，现在看如下例子:

<br>

    假设我们一个钟的指针为6点整，现在要将指针变为3点整，我们可以逆时针旋转3个单位，也可以顺时针旋转9个单位，可以这样理解.
    表盘只能表示12个数，即只能表示1~12间的数，那么
    逆时针 : 3 = 6 - 3
    顺时针 : 6 + 9 = 15 = 12 + 3 因为表盘最多只能表示到12 那么超过12的部分又从12开始算，相当于模12(mod 12) 那么就可以看成 3 <=> 9 + 6
    
    这里咱们就找到了 : 加上9 和 减去3 作用相同,我们称 9和-3是在模12的条件互为补数
    
    注意: 作用相同必须是在 mod 12 的条件下，不然是错误的


<br>

###  经过上钟表的例子，我们发现，在模一定的情况下，我们可以找到加一个数和减另外一个数产生的效果相同<font style="color:red;">(产生这种现象主要是因为模一定，数据位数一定，在运算过程中可能会产生进位，因为位数一定，进位无效，所以出现加一个数和减一个数效果相同)</font>,再看如下例子:

<br>

现知道4为二进制数1010,咱么通过0000，有几种方式得到1010呢(数字只有4位)

        0000            0000
    +   1010        -   0110
    --------        --------
        1010            1010

     显然,因为数字只有4位，通过第二种计算也能得到与第一种相同的结果，这里我们就可以称 1010 和 -0110 在模16的条件下，互为补数,而且不难得知:两补数绝对值之和为模的值
        1010  = | 1010|
    +   0110  = |-0110|
    --------
       10000  = 16     

经过上述计算后，我们发现妙不可言，但是接下来出现新的问题：

我们令 $ X=1010 > 0 $ , $ Y=-0110 $  我们可以进行如下推导:

$ \because $
$ 0 + X = X $且$ 0 -(-X) = X $      
$ \therefore $可以认为$ X $为$ -(-X) $的在模16下的补数,即 <font color="red"> $ X为自己的补数 $</font>

又 $ \ because $ 在上述推导中已经发现，$ X也为Y的补数 $

那么问题来了: <font color="red">$ 怎么分辨这X究竟代表谁的补数呢? $</font>

<br>


###  这时候我们引入符号位,若真值为n位,那么加上符号位过后将变成n+1

+   我们令 $ 1,1010 $ 表示$ Y(-0110) $的补数
+   再令$ 0,1010 $表示$ X(1010) $的补数
+   此时我们已经能分辨$ X,Y $的补数，那么这两个补数是怎么来的?

### 如下:

+   已知上面的例子是模16的即    $ mod2^4 $ , 即<font color="red">真值有$ n=4 $位</font>
+   补数其实是通过如下计算得到
+   $ 2^{n+1} + 原数真值 $,即<font color="red"> $ 1\overbrace{0···0}^{(n+1)个} + X(真值) $</font>
+   如上例子:

+   
```
  1 00000      1 00000
+   1010    -     0110
--------     ---------
  0,1010        1,1010
```

### 经过上述推导我们可以得出补码的一般公式:

1.  > 整数:
    >   + <font color="red">$ mod2^{n} $</font>
    >   + 在字长为n+1位的时候,数值部分为n位(真值n位),这时候补码可以表示为:
    >    $$ [X]补 = \begin{cases} 0,X & \text {$ 2^n-1 \geq X \geq 0 $} \\ 2^{n+1}+X(真值) = 2^{n+1}-|X| &  \text{$ 0>X \geq -2^n $} \end{cases} $$

2.  > 小数:
    >   + <font color="red">mod 2 = $ 2^1 $</font>
    >   $$ [X]补= \begin{cases} X(真值) & \text {$ 1 \gt X \geq 0 $} \\ 2+X(真值)=2-|X| &  \text{$ 0>X \geq -1 $} \end{cases} $$ 
    >   + <font color="red">mod 4 = $ 2^2 $</font>
    >   $$ [X]补= \begin{cases} X(真值) & \text {$ 1 \gt X \geq 0 $} \\ 4+X(真值)=4-|X| &  \text{$ 0>X \geq -1 $} \end{cases} $$


<br> 

### 注意:
#### 经过上面推导我们已经知道了补码的公式,现在看看补码中0的表示,带入上式
1. >  整数(字长n+1位):
   >  + $$ [X]补= \begin{cases} 0,\overbrace{0···0}^{n个} & \text {$ X = +0 $} \\  0,\overbrace{0···0}^{(n)个}  &  \text{$ X= -0 $} \end{cases}
   >  + 计算过程如下:
   > 
    10 $ \overbrace{0···0}^{n个} $

 \-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; $ \overbrace{0···0}^{n个} $
 
\-----------------<br>
&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10,$ \overbrace{0···0}^{n个} $&nbsp;&nbsp;&nbsp;&nbsp;由于字长只有n+1位,最高位的1丢掉，变成<font color="red">$ 0,\overbrace{0···0}^{n个} $</font>
#### 通过上述计算发现，补码0只有一种表示方式=====>  $ 0,\overbrace{0···0}^{n个} $, 那么补码$ 1,\overbrace{0···0}^{n个} $表示什么呢?我们,我们通过公式还原其真值:
>   $ \because X(真值) = -(2^{n+1} - [X]补) $
> 
>   $ \therefore X(真值) = -(10\overbrace{0···0}^{n个}-1\overbrace{0···0}^{n个}) = -1\overbrace{0···0}^{n个} = -2^n $,所以其对应真值为-2^n
>
> <font color="red">注意在计算的时候做的是普通的算术计算,不需要考虑补码的正负，这样才能算出来真值</font>

### 此时我们发现,在原码中，0有两种表示,在补码中0只有一种表示:
### <font color="red">假设为n+1位字长，一位符号位,n位数字位</font>
1. 原码:
   >    $ +0=0, \overbrace{0···0}^{n个} $
   >
   >    $ -0=1, \overbrace{0···0}^{n个} $
2. 补码:
   >    $ +0=0, \overbrace{0···0}^{n个} $
   > 
   >    $ +0=0, \overbrace{0···0}^{n个} $

### 我们会发现补码的$ 1,\overbrace{0···0}^{n个} $用来表示真值的$ -2^n $,而原码的$ 1,\overbrace{0···0}^{n} $用来表示$ -0 $

<hr>

### 现在我们已知字长为n+1,符号位1位，数值位n位，原码和补码分别所能表示的真值范围

1. 原码:
    >  $ 1,\overbrace{1···1}^{n个} $ <font color="red">~</font> $ 1,\overbrace{0···0}^{n个} $&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;$ 0,\overbrace{0···0}^{n个} $ <font color="red">~</font> $ 0,\overbrace{1···1}^{n个} $
    >
    >即n+1位字长，1位符号位的原码可表示真值X的范围为
    >
    > $ -(2^n-1) \leq X \leq -0 $ &nbsp;&nbsp;&nbsp;&nbsp;   ~   &nbsp;&nbsp;&nbsp;&nbsp;$ 0 \leq X \leq 2^n-1 $
2. 补码：
    >$ 1,\overbrace{0···0}^{n个} $ <font color="red">~</font> $ 1,\overbrace{1···1}^{n个} $&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;$ 0,\overbrace{0···0}^{n个} $ <font color="red">~</font> $ 0,\overbrace{1···1}^{n个} $
    >
    >即n+1位字长，1位符号位的补码可表示真值X的范围为
    >
    > $ -2^n \leq X \leq 0 $ &nbsp;&nbsp;&nbsp;&nbsp;   ~   &nbsp;&nbsp;&nbsp;&nbsp;$ 0 \leq X \leq 2^n-1 $
3. 可以观察到，补码比原码 多表示了一个$ -2^n $,因为补码0只有一种表示方法,而原码0有2中表示方法

### 再看小数所能表示的范围

1. 原码:
   > $ 1.\overbrace{1···1}^{n个} $ <font color="red">~</font> $ 1.\overbrace{0···0}^{n个} $&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;$ 0.\overbrace{0···0}^{n个} $ <font color="red">~</font> $ 0.\overbrace{1···1}^{n个} $
   >
   >即n+1位字长，1位符号位的原码可表示真值X的范围为
   >
   > $ 2^{-n}-1 \leq X \leq 0 $ &nbsp;&nbsp;&nbsp;&nbsp;   ~   &nbsp;&nbsp;&nbsp;&nbsp;$ 0 \leq X \leq 1-2^{-n} $
2. 补码:
   > $ 1.\overbrace{0···0}^{n个} $ <font color="red">~</font> $ 1.\overbrace{1···1}^{n个} $&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;$ 0.\overbrace{0···0}^{n个} $ <font color="red">~</font> $ 0.\overbrace{1···1}^{n个} $
   >
   >即n+1位字长，1位符号位的原码可表示真值X的范围为
   >
   > $ -1 \leq X \leq -2^{-n} $ &nbsp;&nbsp;&nbsp;&nbsp;   ~   &nbsp;&nbsp;&nbsp;&nbsp;$ 0 \leq X \leq 1-2^{-n} $
3. 模2的小数的补码比原码所表示的真值多了个-1,这也是0的表示造成的


### 补码转换为真值
1.  经过上诉观察可以得出，要得到真值，只需要将补码的数值为按位取反，末位加一即可得到
2.  例如:
    > | 补码 |  真值 | 原码 |
    > | :-:| :-:| :-:|
    > | 1,1010|-(0)0110|1,0110|
    > | 1,0001|-(0)1111|1,1111|
    > | 0,1010|+(0)1010|0,1010|
    > | 0,0001|+(0)0001|0,0001|
3. 经过上表我们会发现，补码，真值，原码有小小的规律:
   > + 针对负数
   > > 1. 真值即补码去除符号位过后的数值为，按位取反末位再加上1得到
   > > 2. 原码即补码符号位保持不动，按位取反末位加上1得到
   > > 3. 原码相对真值多了符号位
   > + 针对正数
   > > 1. 补码，原码形式完全一样,真值为前者的数值加上符号位
<hr>
<h2>反码</h2>


### 经过上述补码，原码，真值之间的关系，中间有个取反的过程,
反码为这样定义：
>   针对负数：
>   1. 反码为符号位不变，各位按位取反
>
>   针对正数
>   1. 反码跟原码保持一样
>   2. 即有 原码 = 补码 = 反码
>

<hr>
<h2>移码</h2>

### 真值不能直观的反应数的大小
再看上面的表:
>   
+   > | 补码 |  真值 | 原码 |
    > | :-:| :-:| :-:|
    > | 1,1010|-0110|1,0110|
    > | 1,0001|-1111|1,1111|
    > | 0,1010|+1010|0,1010|
    > | 0,0001|+0001|0,0001|

我们发现从真值很难看出数的相对大小，移码就是将字长n+1的数,加上$ 2^n $，即将所有数在数轴上右移$ 2^n $个单位,这样就能直观的看出大小了,如下
>   
+   > | 真值 | 移码 |
    > | :-:| :-:|
    > |-0110|01010|
    > |-1111|00001|
    > |+1010|11010|
    > |+0001|10001|
    这样就能直观的看出数的大小了

---------------
