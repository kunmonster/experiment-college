<h1>逆波兰式(后缀表达式的转换)</h1>

<h2>1.简介</h2>

  1. 在计算机编译源代码的时候，语法和语义分析通常需要借助站栈来进行，计算机没有办法像人一样一眼看出表达式中各部分的优先级，所以借助栈这个工具，生成一种能让计算机不用关心优先级，直接计算的式子即为后缀表达式(符号在操作数后面)

<h2>2.例子</h2>

  1. 中缀表达式$a+b/(c*d)-e*(f/g)$,这个式子如果是人来计算，将会很容易，先计算括号里面的，再根据优先级计算出剩余的，但是计算机可没有这么轻松，但是将这个式子转换为：$abcd*/+efg/*-$ ,再将这个式子放入栈中计算，如下
    
  + 
  +  | d |
     | :-: |
     | c |
     | b |
     | a |
   + 当前剩余表达式
     | * | / | + | e | f | g | / | * | - |
     | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | 

    当程序遇到操作数时，将操作数入栈,上述入栈直到遇到运算符*，这时候取操作数2 = 栈顶(d)，栈顶出栈，操作数1 = 栈顶(c),再将这两个操作数使用运算符计算后的结果入栈,栈变成
    
  +  
    | <font color="red">$c*d$</font> |
    | :-: |
    | b |
    | a |
  + 当前剩余表达式
  
     | / | + | e | f | g | / | * | - |
     | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | 

  重复上述操作，下一个为运算符，那么取操作数2=栈顶(c*d) , 栈顶出栈,操作数1 = 栈顶(b),用遍历到的操作符计算$b/(c*d)$,入栈

  +  
    | <font color="red">$b/(c*d)$</font> |
    | :-: |
    | a |
  + 当前剩余表达式

    | + | e | f | g | / | * | - |
    | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
  + 重复上述操作，下一个为运算符，那么取操作数2=栈顶(b/(c*d)) , 栈顶出栈,操作数1 = 栈顶(a),用遍历到的操作符计算$a+b/(c*d)$
  +  
    | <font color="red">$a+b/(c*d)$</font> |
    | :-: |
  
    $\vdots$

  + 以上就是后缀表达式的计算过程
  + 这种式子对计算机来说更容易计算，那怎么将中缀表达式转换成后缀表达式呢?

<h2>3.中缀表达式转换为后缀表达式</h2>  

  + 首先确定运算符的优先级
  +  
    | 运算符 | ( | + | - | * | / | ) |
    | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
    | 优先级 | 0 | 1 | 1 | 2 | 2 | 3 |
  + 给定一个表达式 $a+b/(c*d)-e*(f/g)$
  + 转换过程如下
  + + case 1 : 如果当前字符为操作数，那么直接加入后缀表达式
  + + case 2 : 如果当前字符为左括号(,那么将其入栈
  + + case 3 : 如果当前字符为右括号),那么将栈顶符号出栈加入后缀表达式，直到所有的栈顶为左括号(,再将左括号出栈
  + + case 4 : 如果当前字符为运算符,此时考察符号栈
  + + + a :  若符号栈为空，直接将该符号进栈
  + + + b :  若符号栈不为空，查看栈顶符号的优先级，如果栈顶符号的优先级大于或者等于当前符号的优先级，那么将栈顶出栈加入到后缀表达式，然后重复case4,直到遇到栈顶操作符的优先级小于当前操作符的优先级，将当前操作符入栈，继续处理下一个字符，直到字符串为空。
  + + case 5 : 表达式串已经为空，这时候查看操作符栈是否为空，为空则结束，不为空那么将栈内元素依次出栈加入到后缀表达式，这样就转换完成了。