KMP 算法
=======

1. 简介
   + (m,n分别为主串子串的长度)
   + kmp算法是串的模式匹配(子串在主串中的定位操作--求子串(常称模式串)在主串中的位置)
   + 常规的模式匹配算法有我们最爱的暴力匹配,无疑其复杂度肯定是O(m*n),但是kmp算法的时间复杂度只有O(m+n)
2. kmp详解 
 
   + 一个例子
   + 字串为 *__abcac__* 
   + | 索引 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 |   
     | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
     | 主串 | a | b | <font color="red">a</font> | b | c | a | b | c | a | c | b | a | c |  
     | 子串 | a | b | <font color="red">c</font> | a | c |

     令主串索引为i,字串索引为j。当S\[i\] == T\[j\] 时候，i和j都往后滑一个位置,当不等的时候，传统的方法为将i从上一次开始位置往后滑一位，然后j滑回第一位，继续匹配,如下

   + | 索引 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 |   
     | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
     | 主串 | a | b | a | b | c | a | b | c | a | c | b | a | c |  
     | 子串 |   | a | b | c | a | c |
     | 比较位置 |   | i,j |
    
     这个例子中，i还需要滑动一次才能完全匹配

     分析这种做法,在碰到不匹配时，i和j都被滑回去了，最坏情况下O(m*n)的复杂度

     现在观察，当第三个位置产生不匹配的时候，说明前两个位置肯定是完全匹配的,即<font color="red">S<sub>1~(i-1)</sub> == T<sub>1~(j-1)</sub></font>因为S\[i\] == 'a'且T\[1\] == 'a',即<font style="color:red">S<sub>1~(i-1)</sub>的后缀与T<sub>1~(j-1)</sub>的前缀相等，其实就是T<sub>1~j-1</sub>的最长相等前缀，我们这时候可以将字串的第一个元素与主串第三个元素对齐来比较，如下：</font>

   + | 索引 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 |   
     | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
     | 主串 | a | b | <font color="red">a</font> | b | c | a | b | c | a | c | b | a | c |  
     | 子串 |   |   | <font color="red">a</font> | b | c | a | c |

     这时候又在第7个位置发生了失配现象 ， 如果使用暴力求解的话，i又得滑到4，j滑回1，他们并不相等，又得一直滑，继续使用上述方法，找<font color="red">已经匹配部分的最长公共前后缀</font>

     已经匹配部分为S<sub>3~6</sub> == T<sub>1~4</sub>,这一次我们把前后缀写出来

     给出前后缀定义:

     * <font color="red">对于一个任意串,如<em>abab</em></font>

     * * <font color="red">前缀 : 除了最后一个字符，前面的字符按顺序组成的字串</font>
     * * * 如上述abab,除了最后一个字符b，前面的字符组成的子串为\{ a , ab , aba \}
     * * <font color="red">后缀 : 除了第一个字符，后面的字符按顺序组成的字串</font>
     * * * 如上述abab,除了第一个字符a,后面的字符组成的子串为\{b , ba , bab\}
     * * <font color="red">最长公前后缀 : 前缀集合和后缀集合求交集所得到的结果中长度最长的串</font>
     * * * 如上述的$\{a , ab , aba\} \cap \{b , ba , bab\} = \{ \emptyset \}$
     * * * 交集为空，所以最长公共前后缀为空，长度为0
     
     现在看回刚刚的题,我们找出已经匹配部分的最长公共前后缀:

     已经匹配部分:

     a , b , c , a 

     前缀集合 = \{ a , ab ,abc \}
     后缀集合 = \{ a , ac , acb \}，很容易得到他们两个的交集为a，即最长公共前后缀长度为q
     此时我们可以这样移动

   + | 索引 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 |   
     | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
     | 主串 | a | b | <font color="blue">a</font> | b | c | <font color="red">a</font> | b | c | a | c | b | a | c |  
     | 子串 |   |   |  |  |  | <font color="red">a</font> | b | c | a | c |
     | 比较位置 |  |  |  |  |  |  |  i,j | 

     这样就能直接匹配成功了

    + 不难发现，i并没有改变原来的位置,只是j滑到了子串的第二个字符处,其实就是<font color="red">$j=最长公共前后缀长度+1$</font>

    + <font color="red">所以得出一般结论：
    当第i,j个位置发生失配时，j应该滑到已经匹配子串的最长公共前后缀长度+1的位置</font>

    +  可以将每个位置失配时j需要滑动的位置保存下来,这里将其定义为next数组，这里为了方便，串的索引和next数组的索引都是从1开始的

    
    + 由上述推导可以得到，next数组每个位置其实存放的就是对应j位置之前的子串的最长公共前后缀长度+1。如果人工用手来算那么这个数组计算的难度不大，那怎么通过编程来实现呢？

    + 有以下一般推导:
      
      + 令next\[T.length(模式串的长度)\],next\[j\]表示当第j个元素失配的时候，j元素需要滑动的位置

      + case 1 :
      + + 当第一个位置就失配时，这时候子串的索引已经在最前面了，这时候需要把子串第一个字符与主串下一个字符比较，即主串向后滑动一个位置，可以令next\[1\] = 0<font color="red">(注意不管主串还是子串的索引都从1开始)</font>,匹配的时候发现为0就直接将主串索引加一
      + case 2 :
      + + 当第j个位置失配的时候($j \neq 0$),这时候我们，我们假设j需要滑动的位置为k，那么有如下表达式
      + + T<sub>1~k-1</sub> = T<sub>j-k+  1~j-1</sub>
      + + + 移动过后有两种情况
      + + + 1. T\[k\] == T\[j\] , 这时候T<sub>1~k-1</sub>的前缀与T<sub>j-k+1~j-1</sub>在相等的基础上后面多了个T\[k\] == T\[j\],这时候显然next\[j+1\] = next\[j\]+1 = k+1
      + + + 2. $T[k] \neq T[j]$，用图来表示
  
            | 索引 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 
            | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
            | 模式 | a | b | a | c | a | b | c | d |
            | 索引 |   |   | k |   |   |   | j | j+1 |

            当j发生失配的时候，这时候j滑到k

             | 索引 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 
            | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
            | 模式1(T1) | a | b | a | c | a | b | c |   |
            | 模式2(T2) |   |   |   |   | a | b | a | c  |
            | 索引 |   |   |   |   |   |   | j,k | j+1 |

            这时候我们发现，$T1[j] \neq T2[K]$,那么这时候next\[j+1\]显然是不能等于next\[j\]+1即k+1的,因为滑过来的话就没办法满足T<sub>1~k</sub> == T<sub>j-k+1~j</sub>,那么此时next\[j+1\]应该怎么求呢？

            我们可以继续把这个问题看成模式串的匹配问题：

            当k发生失配的时候，只需要令k = next\[k\]即可,然后再继续上述步骤，直到找到T\[j\] == T\[[next[j]]\]或者没有任何匹配情况，直接最终滑到第一个元素
            
            这种情况可以写出如下公式

            $next[j+1] = max\{k | T<sub>1~k</sub> == T<sub>j-k+1~j</sub> \}$

      + case 3: 
      + + 当不满足上述情况的时候直接置为1

      可以写出最终的推导公式:
      
      $$next[j] =\begin{cases}
         0 & j==1 \\
         max\{k | 1<k<j 且 T_(1(k-1)) == T_(j-k+1-(j-1)) \} & 当集合不为空 \\
         1 & 其他情况
      \end{cases}$$
          
