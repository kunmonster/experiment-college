KMP 算法
=======

1. 简介
   + (m,n分别为主串子串的长度)
   + kmp算法是串的模式匹配(子串在主串中的定位操作--求子串(常称模式串)在主串中的位置)
   + 常规的模式匹配算法有我们最爱的暴力匹配,无疑其复杂度肯定是O(m*n),但是kmp算法的时间复杂度只有O(m+n)
2. kmp详解 
 
   + 一个例子
   + 字串为 *__abcac__* 
   + | 索引 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 |   
     | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
     | 主串 | a | b | <font color="red">a</font> | b | c | a | b | c | a | c | b | a | c |  
     | 子串 | a | b | <font color="red">c</font> | a | c |

     令主串索引为i,字串索引为j。当S\[i\] == T\[j\] 时候，i和j都往后滑一个位置,当不等的时候，传统的方法为将i从上一次开始位置往后滑一位，然后j滑回第一位，继续匹配,如下

   + | 索引 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 |   
     | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
     | 主串 | a | b | a | b | c | a | b | c | a | c | b | a | c |  
     | 子串 |   | a | b | c | a | c |
     | 比较位置 |   | i,j |
    
     这个例子中，i还需要滑动一次才能完全匹配

     分析这种做法,在碰到不匹配时，i和j都被滑回去了，最坏情况下O(m*n)的复杂度

     现在观察，当第三个位置产生不匹配的时候，说明前两个位置肯定是完全匹配的,即<font color="red">S<sub>1~(i-1)</sub> == T<sub>1~(j-1)</sub></font>因为S\[i\] == 'a'且T\[1\] == 'a',即<font style="color:red">S<sub>1~(i-1)</sub>的后缀与T<sub>1~(j-1)</sub>的前缀相等，其实就是T<sub>1~j-1</sub>的最长相等前缀，我们这时候可以将字串的第一个元素与主串第三个元素对齐来比较，如下：</font>

   + | 索引 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 |   
     | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
     | 主串 | a | b | <font color="red">a</font> | b | c | a | b | c | a | c | b | a | c |  
     | 子串 |   |   | <font color="red">a</font> | b | c | a | c |

     这时候又在第7个位置发生了失配现象 ， 如果使用暴力求解的话，i又得滑到4，j滑回1，他们并不相等，又得一直滑，继续使用上述方法，找<font color="red">已经匹配部分的最长公共前后缀</font>

     已经匹配部分为S<sub>3~6</sub> == T<sub>1~4</sub>,这一次我们把前后缀写出来

     给出前后缀定义:

     * <font color="red">对于一个任意串,如<em>abab</em></font>

     * * <font color="red">前缀 : 除了最后一个字符，前面的字符按顺序组成的字串</font>
     * * * 如上述abab,除了最后一个字符b，前面的字符组成的子串为\{ a , ab , aba \}
     * * <font color="red">后缀 : 除了第一个字符，后面的字符按顺序组成的字串</font>
     * * * 如上述abab,除了第一个字符a,后面的字符组成的子串为\{b , ba , bab\}
     * * <font color="red">最长公前后缀 : 前缀集合和后缀集合求交集所得到的结果中长度最长的串</font>
     * * * 如上述的$\{a , ab , aba\} \cap \{b , ba , bab\} = \{ \emptyset \}$
     * * * 交集为空，所以最长公共前后缀为空，长度为0
     
     现在看回刚刚的题,我们找出已经匹配部分的最长公共前后缀:

     已经匹配部分:

     a , b , c , a 

     前缀集合 = \{ a , ab ,abc \}
     后缀集合 = \{ a , ac , acb \}，很容易得到他们两个的交集为a，即最长公共前后缀长度为q
     此时我们可以这样移动

   + | 索引 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 |   
     | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
     | 主串 | a | b | <font color="blue">a</font> | b | c | <font color="red">a</font> | b | c | a | c | b | a | c |  
     | 子串 |   |   |  |  |  | <font color="red">a</font> | b | c | a | c |
     | 比较位置 |  |  |  |  |  |  |  i,j | 

     这样就能直接匹配成功了

    + 不难发现，i并没有改变原来的位置,只是j滑到了子串的第二个字符处,其实就是<font color="red">$j=最长公共前后缀长度+1$</font>

    + <font color="red">所以得出一般结论：
    当第i,j个位置发生失配时，j应该滑到已经匹配子串的最长公共前后缀长度+1的位置</font>

    +  可以将每个位置失配时j需要滑动的位置保存下来,这里将其定义为next数组，这里为了方便，串的索引和next数组的索引都是从1开始的

    
    + 由上述推导可以得到，next数组每个位置其实存放的就是对应j位置之前的子串的最长公共前后缀长度+1。如果人工用手来算那么这个数组计算的难度不大，那怎么通过编程来实现呢？

    + 有以下一般推导:
      
      + 令next\[T.length(模式串的长度)\],next\[j\]表示当第j个元素失配的时候，j元素需要滑动的位置

      + case 1 :
      + + 当第一个位置就失配时，这时候子串的索引已经在最前面了，这时候需要把子串第一个字符与主串下一个字符比较，即主串向后滑动一个位置，可以令next\[1\] = 0<font color="red">(注意不管主串还是子串的索引都从1开始)</font>,匹配的时候发现为0就直接将主串索引加一
      + case 2 :
      + + 当第j个位置失配的时候($j \neq 0$),这时候我们，我们假设j需要滑动的位置为k，那么有如下表达式
      + + T<sub>1~k-1</sub> = T<sub>j-k+  1~j-1</sub>
      + + + 移动过后有两种情况
      + + + 1. T\[k\] == T\[j\] , 这时候T<sub>1~k-1</sub>的前缀与T<sub>j-k+1~j-1</sub>在相等的基础上后面多了个T\[k\] == T\[j\],这时候显然next\[j+1\] = next\[j\]+1 = k+1
      + + + 2. $T[k] \neq T[j]$，用图来表示
  
            | 索引 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 
            | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
            | 模式 | a | b | a | c | a | b | c | d |
            | 索引 |   |   | k |   |   |   | j | j+1 |

            当j发生失配的时候，这时候j滑到k

             | 索引 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 
            | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
            | 模式1(T1) | a | b | a | c | a | b | c |   |
            | 模式2(T2) |   |   |   |   | a | b | a | c  |
            | 索引 |   |   |   |   |   |   | j,k | j+1 |

            这时候我们发现，$T1[j] \neq T2[K]$,那么这时候next\[j+1\]显然是不能等于next\[j\]+1即k+1的,因为滑过来的话就没办法满足T<sub>1~k</sub> == T<sub>j-k+1~j</sub>,那么此时next\[j+1\]应该怎么求呢？

            我们可以继续把这个问题看成模式串的匹配问题：

            当k发生失配的时候，只需要令k = next\[k\]即可,然后再继续上述步骤，直到找到T\[j\] == T\[[next[j]]\]或者没有任何匹配情况，直接最终滑到第一个元素
            
            这种情况可以写出如下公式

            $next[j+1] = max\{k | T<sub>1~k</sub> == T<sub>j-k+1~j</sub> \}$

      + case 3: 
      + + 当不满足上述情况的时候直接置为1

      可以写出最终的推导公式:
      
      $$next[j] =\begin{cases}
         0 & j==1 \\
         max\{k | 1<k<j 且 T_(1(k-1)) == T_(j-k+1-(j-1)) \} & 当集合不为空 \\
         1 & 其他情况
      \end{cases}$$
          
    + 这里给出代码实现(cpp):
    + + 使用更容易理解的字符串从一开始索引
    + + +  
          ```
          void get_Next(String T, int * next){
            int j = 1 ,k = 0; //这里j表示失配的位置,k表示j失配的时候需要滑动的位置,即k = next[j]
            next[1] = 0;      //令next[1] = 0 : next也从
            while(j<T.length()){
                if(k == 0 || T[j] == T[k]){
                  //当j发生失配的时候,查找其滑动的位置,发现next[k] == next[j]此时说明,最长前后缀长度加一了,
                  那么当j发生失配的时候，只需要查找k+1位置就行
                  ++j;
                  ++k;
                  next[j] = k;
                }
                else{
                  //next[j] != next[k],此时还要匹配最长前后缀就得去T1~k-1找了即
                  k = next[k];
                }
            }
          }
          ```
    + + 正常索引版本(字符串和next数组都从0开始索引)
    + + + 
          ```
          void get_Next(String T, int * next){
            int j = 0 ,k = -1; //这里j表示失配的位置,k表示j失配的时候需要滑动的位置,即k = next[j]
            next[0] = -1;      //令next[1] = 0 : next也从
            while(j<T.length()){
                if(k == -1 || T[j] == T[k]){
                  //当j发生失配的时候,查找其滑动的位置,发现next[k] == next[j]此时说明,最长前后缀长度加一了,
                  那么当j发生失配的时候，只需要查找k+1位置就行
                  ++j;
                  ++k;
                  next[j] = k;
                }
                else{
                  //next[j] != next[k],此时还要匹配最长前后缀就得去T1~k-1找了即
                  k = next[k];
                }
            }
          }
          ```
    + + 此时已经可以写出完整的kmp算法代码了
    + + + 
          ```
          //这里索引均是从0开始
          int Index_kmp(String S , String T ,int * next){
            int i = -1,j = -1;
            while(i < S.length() && j < T.length()){
              if(j == -1 || S[i] == T[j]){
                ++i;
                ++j;
              }
              else{
                j = next[j];
              }
            }
            if(j >= T.length()){
              return i-T.length();
            }   
          }
          ```
    + + 到这里kmp算法基本上已经算是掌握了,但是在实际运用中,还有优化的空间。如下例子：
    + + + 
            
          | 主串 | a | a | a | <font color="red">b</font> | a | a | a | a | b |
          | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
          | 模式 | a | a | a | <font color="red">a</font> | b |   |  |   |
          | j | 1 | 2 | 3 | 4 | 5 |  |   |  |
          | next\[j\] | 0 | 1 | 2 | 3 | 4 |
          | nextval\[j\] | 0 | 0 | 0 | 0 | 4 |

          可以看到上述第四个位置发生了失配现象，按照之前的做法，我们直接令j=next\[j\],当然这种做法正确，但是这里next\[j\]为3,又去查阅T\[3\]发现它与发生失配的第四个元素相等，那么将j滑到这里后，再与主串b比较，显然结果一样，那我们可将next优化为nextval数组，如图中的nextval数组，查询这个数组，发现当第二个位置失配的时候，这里直接滑到0，相当从主串的下一个位置开始比较,中间就省略了使用next数组的荣冗余比较步骤，可以在一定程度上提升效率

    + + 代码实现
    + + +
          ```
          void get_Next(String T, int * nextval){
            int j = 0 ,k = -1; //这里j表示失配的位置,k表示j失配的时候需要滑动的位置,即k = next[j]
            nextval[0] = -1;      //令next[1] = 0 : next也从
            while(j<T.length()){
                if(k == -1 || T[j] == T[k]){
                  //当j发生失配的时候,查找其滑动的位置,发现next[k] == next[j]此时说明,最长前后缀长度加一了,
                  那么当j发生失配的时候，只需要查找k+1位置就行
                  ++j;
                  ++k;
                  if(T[j] != T[k]) nextval[j] = k;
                  else nextval[j] = nextval[k];
                }
                else{
                  //next[j] != next[k],此时还要匹配最长前后缀就得去T1~k-1找了即
                  k = nextval[k];
                }
            }
          }
          ```      

<h1>上述就是我对kmp的理解过程
