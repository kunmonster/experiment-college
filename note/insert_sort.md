
[TOC]

# 插入排序

## 简介

	插入排序是一种比较符合直观思维的基于比较的排序方法,每次将一个待排序的记录按其关键字的大小插入到前面已经有序的序列中去,直到全部记录排序完成,主要有以下三种插入排序:直接插入排序,折半(二分)插入排序,希尔(shell)排序.
<hr>

## 直接插入排序

### 1.原理:
1.	如果序列长度小于等于1,无需排序
2.	序列长度大于等于2,则从第2个元素开始:
	+ 当前元素大于或等于前一个元素,此元素无需插入到前面,索引指向后一个元素
	+ 当前元素小于前一个元素,此元素需要插入到前面的有序序列中,插入过程如下:
	> 1. 将需要插入的元素暂存
	> 2. 从前一个元素开始,比较是否大于需要插入的元素,是则将前一个元素向后移动一个位置,索引指向前一个元素的前一个元素,直到索引小于0或者索引指向的元素小于或者等于需要插入的元素(索引移动的同时需要移动元素)
	> 3. 插入元素到当前索引的下一个位置
	> 4. 外层索引向后移动

### 2. 代码:

```c++
void stright_insert_sort(Element<T> *arr, int len) {
  if (len <= 1) return;
  // store the insert_Needed element into guard
  Element<T> guard;
  int j = 0;
  for (int i = 1; i < len; ++i) {
    if (*(arr + i) < *(arr + i - 1)) {
      //当前元素小于前一个元素
      guard = *(arr + i);
      for (j = (i - 1); (j >= 0) && (guard < arr[j]); --j) arr[j + 1] = arr[j];
      arr[j + 1] = guard;
    }
  }
}
```

### 3.效率分析

#### 时间效率:

+ 最好情况 : 序列已经为关键字有序,此时时间主要消耗在比较大小上面,最好情况下只需要n次比较,时间复杂度为O(n)
+ 最坏情况 : 序列按关键字倒序排列,此时每个元素都需要往前插,此时时间主要花在移动元素上面,因为要把第i个元素插到前面有序序列去,倒序情况下$遍历到第i个元素时候将要移动i-1个元素$
> 如下:
>
> | 索引 | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
  | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
  | 关键字 | 10 | 9 | 8 | 7 | 6 | 5 | 4|
  显然第一个元素不需要移动,遍历第二个元素时,需要将10移动(遍历第二个元素,移动$(2-1)$次)以此类推
所以总的移动次数是$0+1+2+………n-1 = n(n+1)/2 = O(n^2)$此外还有比较的开销,与移动次数相同,所以其数量级一样
+ 平均情况 : $O(n^2)$

### 空间效率
+ 因为此算法在过程中,只需要一个变量暂存当前插入值,显然空间复杂度为$ O(1) $



### 4. 稳定性
+ 因为遍历顺序是从左至右,且插入是插入到第一个比插入元素小或相等的元素的后面的,即相同元素的相对位置并不改变,显然此排序是稳定排序

<hr>

## 折半(二分)插入排序

### 原理:

1. 因为插入排序思想就是把当前元素插入到前面有序序列中去,即前面序列已经有序,直接插入排序在找插入位置的时候使用的挨个遍历的方法,根据前面查找的方法,我们可以使用二分的方法,来更快的找到这个插入位置.
2. 虽然在找到插入位置时速度更快,但是插入位置右边元素还是需要整体后移,即移动所需要的时间并没有减少,所以这个操作并不能降低相对于直接插入排序的时间复杂度,只是在找到插入位置的时候加快了速度

### 代码:
```c++
template <typename T>
void binary_insert_sort(Element<T> *arr, int len) {
  if (len <= 1) return;
  //数组长度大于等于1

  Element<T> guard;
  int i, j;
  for (i = 1; i < len; ++i) {
    if (arr[i] < arr[i - 1]) {
      guard = arr[i];
      //得到插入的位置然后插入
      int low = 0, high = i - 1, mid = 0;
      while (low <= high) {
        mid = (low + high) / 2;
        if (guard < arr[mid])
          high = mid - 1;
        else
          low = mid + 1;
      }
      //插入位置为high+1
      //从i的前一个位置开始需要将插入位置开始的数都往后移
      for (j = (i - 1); j >= (high + 1); --j) arr[j + 1] = arr[j];
      arr[high + 1] = guard;
    }
  }
}
```

### 效率分析:
#### 时间效率:
+ 最好情况 : 同直接插入排序$O(n)$
+ 最坏情况 : 同直接插入排序,只是在寻找插入位置的时候比直接插入排序更快,但是时间复杂度的量级仍然是$O(n^2)$

#### 空间效率
+ 同直接插入排序

### 4. 稳定性
+ 因为遍历顺序是从左至右,且插入是插入到第一个比插入元素小或相等的元素的后面的,即相同元素的相对位置并不改变,显然此排序是稳定排序

<hr>

## 希尔排序(shell,缩小增量排序)

### 原理:
1. 将待排序列分成k个特殊子序列,然后分别使每个子序列进行直接插入排序
2. 特殊子序列即把相隔某个增量的序列组成一个子表
3. 缩小增量
4. 直至基本有序

### 代码
```languagec++
template <typename T>
void shell_sort(Element<T> *arr, int len) {
  if (len <= 1) return;
  Element<T> guard;
  int dk, i, j;
  for (dk = len / 2; dk >= 1; dk /= 2) {
    for (i = dk; i < len; ++i) {
      if (arr[i] < arr[i - dk]) {
        guard = arr[i];
        for (j = i - dk; j >= 0 && arr[j] > guard; j -= dk) arr[j + dk] = arr[j];
        arr[j + dk] = guard;
      }
    }
  }
}
```

### 例子:

| 索引 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 元素 | 49 | 38 | 65 | 97 | 76 | 13 | 27 | 49 | 55 | 04 |

1. 取增量初始dk = 5
2. 从第dk+1个元素开始,向前执行直接插入排序(步长为dk)
3. 当前步长遍历完成(一趟)
4. 减小步长,重复上述步骤
5. 直至序列基本有序，对整个序列进行一次直接插入排序

过程如下


| 索引 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 元素 | 49(a) | 38 | 65 | 97 | 76 | 13 | 27 | 49(b) | 55 | 04 |

+ 取dk = 5
+ 形成新子序列

| 索引 | 0 | 5 |
| :-: | :-: |
| 元素 | 49(a) | 13 |

| 索引 | 1 | 6 |
| :-: | :-: |
| 元素 | 38 | 27 |

| 索引 | 2 | 7 |
| :-: | :-: |
| 元素 | 65 | 49(b) |

| 索引 | 3 | 8 |
| :-: | :-: |
| 元素 | 97 | 55 |

| 索引 | 4 | 9 |
| :-: | :-: |
| 元素 | 76 | 04 |
+ 对以上子序列分别进行直接插入排序,原序列变成
| 索引 | 0 | 5 |
| :-: | :-: |
| 元素 | 13 | 49(a) |

| 索引 | 1 | 6 |
| :-: | :-: |
| 元素 | 27 | 38 |

| 索引 | 2 | 7 |
| :-: | :-: |
| 元素 | 49(b) | 65 |

| 索引 | 3 | 8 |
| :-: | :-: |
| 元素 | 55 | 97 |

| 索引 | 4 | 9 |
| :-: | :-: |
| 元素 | 04 | 76 |

| 索引 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 元素 | 13 | 27 | 49(b) | 55 | 04 | 49(a) | 38 | 65 | 97 | 76 |

+ 缩小dk为3, dk = 3,子序列变为

| 索引 | 0 | 3 | 6 | 9 |
| :-: | :-: | :-: | :-: | :-: |
| 元素 | 13 | 55 | 38 | 76 |

| 索引 | 1 | 4 | 7 |
| :-: | :-: | :-: | :-: |
| 元素 | 27 | 04 | 65 |

| 索引 | 2 | 5 |
| :-: | :-: | :-: |
| 元素 | 49(b) | 49(a) |

+ 将子序列排序

| 索引 | 0 | 3 | 6 | 9 |
| :-: | :-: | :-: | :-: | :-: |
| 元素 | 13 | 38 | 55 | 76 |

| 索引 | 1 | 4 | 7 |
| :-: | :-: | :-: | :-: |
| 元素 | 04 | 27 | 65 |

| 索引 | 2 | 5 |
| :-: | :-: | :-: |
| 元素 | 49(b) | 49(a) |


| 索引 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 元素 | 13 | 04 | 49(b) | 38 | 27 | 49(a) | 55 | 65 | 97 | 76 |


+ 再缩小dk = 1,相当于对整个序列执行一次直接插入排序


| 索引 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 元素 | 04 | 13 | 27 | 38 | 49(b) | 49(a) | 55 | 65 | 76 | 97 |

+ 排序完成

+ 通过上述过程我们可以观察到,每次取了dk过后就有dk个子序列
+ 49(a)被移动到49(b)的后面了,显然是不稳定的


### 效率分析:
#### 时间效率:
+ 最好情况 : 序列按关键字有序排列,这样子序列也是有序的,只需要比较,不需要将移动元素,时间复杂度为$O(n)$
+ 最坏情况 : 序列按关键字逆序排列,显然子序列也是逆序,每个子序列都要进行直接插入排序,时间复杂度为$O(n^2)$
+ 平均情况 : 依赖性增量dk的取法，目前无法解决,当n在某个特定的范围时,时间复杂度约为$O(n^{1.3})$

#### 空间效率
+ 仅使用常数个辅助单元,为$O(1)$

### 4. 稳定性
+ 因为每次比较和插入是子序列间进行的,只能保证每次子序列之内为稳定，但是相同大小关键字可能出现在不同的子序列中,如果发生了插入,显然可能导致相同元素相对位置的改变,即不稳定