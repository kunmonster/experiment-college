# C++ Primer Plus note

## 数据处理

1. 命名常用前缀
	* str
	* sz(以空字符结束的字符串)
	* b(布尔值)
	* p(指针)
	* c(单个字符)
	* m_name(类成员)

2. 运算符sizeof(单位字节)
	* 可以对类型名和变量名使用sizeof运算符
	* 形式 sizeof(target) 或者 sizeof target

3. climits头文件 || limits.h
	* 一些关于符号常量的宏定义
	* CHAR_BIT char的位数
	* xxx_MAX xxx的最大值
	* xxx_min xxx的最小值

4. 初始化方式
	* c风格 : type name = value;
	* c++ : type name(value);
	* c++11
		* type name = {value};
		* type name {value};
		* type name = {};  此时变量被初始化为0
	* \{\}c++11列表初始化,使用此种初始化方式的时候,不允许缩窄,即列表的值不能向下赋值给待初始化的变量

5. wchar_t 宽字符类型
	* 程序需要处理的字符集可能无法用一个8位的字节表示(汉字或者日文)
	* 底层实现不一定,可能是各种类型的
	* cin,cout不适用于处理wchar_t因为他们把输入输出看成char流
	* 使用wcin,wcout处理
	* 可以加上L前缀表示宽字符常量和宽字符串

6. char16_t , char32_t
	* wchar_t是固定的可能不能满足需求
	* 两种类型均是无符号的
	* u表示char16_t字符常量或者字符串常量-----char16_t = u'q';
	* U表示char32_t字符常量或者字符串常量-----char32_t=U'\U000022b';

7. const 限定符
	* 创建常量通用格式: const type name = value;
	* 应该在声明的时候对const初始化
	* const 修饰指针变量
		* const修饰指针指向的内容,则内容不可变
			+ 例如const int *p = 8;
			+ 解读上述定义:p是一个指针,指向const int
			+ 上述8不可变,但是p指向的位置可以改变
			+ 称为左定值(const位于*左边)
		* const修饰指针,则指针本身为不可变量
			+ 例如
			```c++
            int a = 8;
            int * const p  = &a;
            ```
            + 上述定义解释--一个const指针,指向int
            + 指针p本身不能改变,但是*p可以改变(p指向的内容)
            + const位于*的右边
        * const修饰指针和指针指向的内容,则指针和指针指向的内容都不可辨
        	+ 例如
        	```c++
            int a = 8;
            const int * const p = &a;
            ```
            + 定义解释---一个const指针,指向const int,此时两个都不能变
        * 注意：int const * p 和 const int * p 都是一样的

8. volatile 关键字
	* 可以在const前面加上,来避开编译器察觉对const的操作

9. 整形提升
	* c++在计算表达式的时候将bool,char,unsigned charm signed char 和 short值转换为int。具体来说,true被转换为1,false被转换为0。

10. 强制类型转换
	* (targetType)variable_name
	* targtType (name)
	* 注意强制类型转换是返回一个转换后类型的值,而不是将原来的变量直接修改


## 复合数据类型

1. 数组
	* 初始化
		* 只有在定义数组时候才能初始化，其他时候不可初始化
		* int arr[n] = {0}; 所有元素都初始化为0
		* int arr[n] = {非零的数}; 第一个元素初始化为该数,其他元素初始化为0
		* int arr[n] = {不足元素个数的k个数}; 初始化前k个数
		* int arr[] = {n个数};初始化n个元素的数组
		* int arr[n] = {};初始化为0;
		* 不能缩窄转换

2. 字符串
	* 字符串输入
		1. 单个输入: cin
		2. 读取一行字符
			* cin.getline(char * str_name,num(要读取的字符数,包含结束符'\0'))------丢弃换行符
			* cin.get()----------将换行符保留在输入序列中
				> 注意如果有多行,当第一个get碰到换行符过后,结束读取,但是换行符还在输入队列中,下一次读取时会最先读取到换行符,此时以为输入结束,显然需要处理
				> 1. 形式1----cin.get(char * str_name,strsize(数组大小,包含'\0'))
				> 2. 形式2----cin.get()读取可读取的下一个字符(即使是换行符),可以是使用此方法在两个形式1cin.get()中间处理换行符
				> 3. 形式3----cin.get(name,ARSize).get():cin本身返回一个cin对象,该对象随后调用get(),完成上述同样功能,还有cin.getline(name1,ArSize1).getline(name2.Arsize2)
			* 上述两个函数都读取一行输入,直到到达换行符
		3. 空行读取
			* 最初做法: 下一条输入语句将在前一条getline()或get()结束读取的位置开始读取
			* 当前做法: 当get()（不是getline()）读取空行后将设置失效位(failbit).意味着接下来的输入将被阻断,但可用cin.clear()恢复
		4. 输入串长度大于数组长度
			* getline()和get()会将余下的字符留在输入队列中,getline()还会设置失效位,关闭后面的输入
		5. 数字和行的混合输入
			* 当用cin输入数字的时候,输入过后使用了回车,回车符还在输入队列中
			* 下一个getline()时候,首先读取到回车符,会认为是空行，并将空字符串赋值给数组
			* 使用cin.get()或者(cin>>数字name).get()来处理

	* string类
		1. 可以使用c风格字符串初始化string对象
		2. 可以使用下标访问string元素,返回值char & 或者 const char &
		3. strlen(c风格字符串)
	* C++11原始值raw
		1. 表示原本的值
		2. R"(content)"----content会原封不动的显示出来
		3. 若原始字符串包含括号那就应该定义为 R"+\*(content)*\+"

3. 结构体
	* 结构体中的位字段
		1. 指定占用特定位数的结构成员(数据类型应该为整型或者枚举)
		2. 格式 unsigned int SN:4(位数)

4. 共用体union
	* 共用体可以存放不同类型的变量,但是只能同时存储其中的一种类型
	* 用途: 当某个数据可能为不同的类型时,可以使用union来减少占用(如果使用结构体,同时定义几种类型,浪费空间)
	* 匿名共用体,union{},无需写名字,成员将成为位于该地址的变量,此时union内部的变量被视为外部的结构体的变量

5. 枚举
	* enum{attr1,attr2....};
	* 在不进行强制转换的时候,只能将定义时使用的枚举量赋值给枚举变量
	* 枚举只能赋值，不能运算,运算会不安全,出现非预期行为
	* 不能将非枚举值赋值给枚举变量,但是可以通过强制类型转换将其赋给枚举变量
	* 可以使用赋值运算显式设置枚举量的值
	* 可以部分显式赋值,未显式赋值的将会比前面的大1
	* 枚举的取值范围: 找出上限,需要知道枚举量的最大值,找到大于这个最大值的,最小的2次幂,减一即为上限。找出枚举量的最小值,如果不小于0则取值范围下限为0，否则采用与寻找上限一样的方式,但是加上符号

6. 指针
	* 当new失败时(系统没有足够的内存无法满足new的请求),这种情况下,new通常会引发异常,在较老的实现中,new将返回0，在c++中，值为0的指针被称为null pointer
	* delete只会释放指针所指的内存,并不会释放指针本身,可以将指针指向另一块内存
	* 一般来说不要创建两个指向统一内存的指针,否则容易出现重复delete
	* delete [] pointer ,删除数组指针
7. 指针与数组
	* 数组名和指针
		1. 若一个指针指向数组,那么 arr_name = &arrname[0] = 指针 = 数组首元素地址
		2. 对数组名使用sizeof会得到数组的大小,但是对数组指针使用szieof就只能得到指针的大小
		3. 对数组名取地址的时候,数组名不会解释为其地址,当对数组名取地址时得到的是整个数组的地址
			* 从数值上来说---&arr[0] === arr(被解释为指向第一个元素的地址) == &arr
			* 但是从意义上来说 &arr[0]单指第一个指向第一个元素的地址,而&arr代表指向整个数组的地址
		4. 数组,vector,array对象


## 第五章

1. typedef 和 #define
	* \#define 当出现并列声明时候,只有第一个才会正确声明
		1. 如#define pointer float *
		2. pointer pa ,pb;
		3. pa为float * 但是pb为float

	* typedef 不会出现上述问题

2. 文件尾条件
	* EOF
		1. 检测到EOF后,cin将两位(eofbit,failbit)都设置为1,可以通过成员函数eof()查看eofbit或者failbit是否被设置,如果检测到EOF则cin.eof()将返回true或者fail()(检检测数据输入不匹配的)返回true,否则返回false,在事后报告,而且在EOF置位后,cin没有用,如果想继续cin需要cin.clear()清除置位
	* cin.get(ch)和ch=cin.get()区别
	* cin.get(ch),赋值参数ch,用于字符输入时候的函数返回值为istream对象(执行bool转换后为true),当到达EOF事后,返回istream对象(执行bool转换后为false)
	* ch = cin.get(),将函数返回值赋给ch,用于字符输入时返回int类型的字符编码,到达EOF时函数返回值为，EOF(-1)

## c++条件分支

1. 逻辑运算符
	* 逻辑运算符的优先级小于算术运算符,所以一般可以1 < 2 || 4 \>5 不用分别打括号
	* ||是一个顺序点,前面的表达式在这个地方之前必须完成,冒号和逗号也是顺序点
	* &&
	* 使用&&来完成取值范围,不要尝试使用数学里面的连续大于小于
	* !(NOT) ,该运算符的优先级高于所有关系运算符,因此要对表达式求反,必须用括号括起来

2. 字符函数库 cctype
	* isalpha(ch) 判断ch是不是字母字符
	* isdigits(ch) 判断字符是不是数字
	* ispunct() 判断字符是不是标点
	* isalnum() 判断参数是不是字母或者数字
	* iscntrl() 判断参数是不是控制字符
	* isdigit() 判断是否为0-9的数字
	* isgraphy() 判断参数是否为除空格之外的打印字符
	* islower() 判断参数是否为小写字母
	* isprint() 判断参数是不是可打印字符(包括空格)
	* isspace() 判断参数是不是标准空白字符,空格,进纸,换行符,回车,水平制表符,或者垂直制表符
	* isupper() 判断参数是不是大写字母
	* idxdigit() 判断参数是不是十六进制数
	* tolower() 判断参数是不是大写字母,如果是返回小写,否则返回参数
	* toupper() 判断参数是不是小写字母,如果是返回其大写,否则返回该参数

3. 简单文件IO
	* 写入文本文件
		1. ofstream对象
			* open()接受c风格字符串作为参数
				1. 当不存在该文件的时候,open()会创建一个
				2. 当本身存在该文件的时候,open默认将文件截短到0,丢弃原有内容,然后将新的输出加入到该文件中
				3. 待添加
			* 文件写入完成后必须close()
	* 读取文本文件
		1. istream对象
			* open()同上的ofstream对象
				1. 当试图打开一个不存在的文件用于输入时,将导致后面使用ifstream对象进行输入时失败
			* is_open()检查文件是否被成功打开
			* good() 指出最后一次读取输入的操作是否成功

## c++编程模块

1. c++不能直接返回数组,但是可以将数组放在结构体里面,返回结构体(对象)

2. 函数原型(为了方便c++编译器,快速知道返回值以及如何解释他们)
	* 可以放在尾部,而且参数列表可以只写类型

3. 参数传递
	* 数组
		1. 数组名传参 typename arr []
		2. 指针传参  int * arr
		3. 在c++中当且仅当,用于函数头或者函数原型,int * arr和int arr[]才是相同的，意味着arr是一个int指针
		4. &arr[i] = arr+i
		5. 将数组作为参数意味着:在函数内部使用的是原来的数组,而传递普通变量的时候,使用的是原来变量的拷贝
		6. 填充数组函数,返回值最好设计为填充成功的数量
		7. 对数组使用const保护
			* const typeName arr[] == const typeName * arr;实际上前者也会被解释为后者
		8. 使用数组区间的函数
			* STL使用超尾概念,指定区间,即对数组而言,标识数组结尾的参数将是指向最后一个元素后面的指针
			* 区间函数通用模板 typeName function(const arrTypeName * begin,const arrTypeName * end)

	* 指针和const
		1. 注意const 指针只是针对当前指针而言的,普通变量还是可以改变
		2. 但是当变量本来就是const变量的时候,指向他的指针必须为指向const的指针,否则编译器报错
		3. 例如
		4. ``` c++
        int age = 20;
        const int * p = &age;
        上述赋值有效,但是p指针是对于age的const指针,age不能通过p指针改变,但是age可以直接通过age赋值改变
        const age = 20;
        int * p_1 = &age;	//当前赋值无效
        const int * p_2= &age; //赋值有效
        但是age都无法改变
        ```
        5. 一级间接关系是允许的,但是二级间接关系不再安全,c++不建议const 二级混合方式,例如
        6. ```c++
			const int ** pp2;
            int * p1;
            const int n = 13;
            pp2 = &p1;	//not allowed在二级间接的时候,不能将const指针指向非const指针(如果数据本身并不是指针,则可以将const数据或非const数据的地址赋值给const指针,但只能将非const数据的地址赋值给非const指针)
            ```
        7. 二维数组传参
         	* typeName (*pointer_name)[size]
         	* 还有另一种: type Name pointer_name[][size],与上述方式完全一,注意传参的时候必须指定列数

		8. 函数和C-风格字符串
			* 将C风格字符串,作为参数传递给函数,有以下三种方式
				1. char数组
				2. 用引号括起的字符串常量(字符串字面值)
				3. 被设置为字符串的地址的char指针
				4. 实际上上述三种方式类型都是char指针(准确的说为char*),因此可以将其作为字符串处理函数的参数
		9. 返回c-风格字符串的函数:返回指针
			* 结构体传参
				1. 按值传递(每次都要创建一个副本),当结构体内容较小的时候,建议采用按值传递
				2. 按引用传递(当结构体较小的时候,适合采用按引用传递,即传递地址)
		10. 函数和string对象

        11. 函数指针
        	* 与函数调用相比,函数指针可以动态改变,在不同时间,不同场合调用不同的函数
        		1. 步骤
        			* 获取函数的地址
        				1. 直接使用函数名(后面不跟参数)即可,也就是说function()是一个函数,则function就是该函数的地址,要将函数作为参数传递,必须传递函数名,不需要加括号

        			* 声明一个函数指针
        				1. 声明指向某种数据类型的指针时,必须指向指针指向的类型,声明指向函数的指针时,也必须指定指针指向的函数类型,这意味着声明应指定函数的返回类型以及函数的特征标(参数列表),也就是说声明应像函数原型那样指出有关函数的信息
        				2. 例如:
        				3. double (*pf)(int);
        				4. 通常写出函数原型,然后将函数名字改写为(*pointer_name)
        				5. 可以将函数赋值给函数指针

        			* 使用函数指针来调用函数
        				1. 方式1: 直接使用指针名字调用pf(params)
        					* 由于函数名字被解释为指向函数的指针(地址),所以有流派认为可以直接使用指针名字来使用函数指针
        				2. 方式2: 使用指针指向的内容来表示(*pf)(params)
        					* 由于函数指针是指向函数的,那么可以使用解除引用符号来调用函数
        		2. 函数指针数组
        			* const double * (*pa[3])(const double *,int) = {f1,f2,f3};
        			* 上述原型的解释:[]优先级大于*,所以pa是一个数组,数组元素是指针,指针指向函数,函数返回const double *

				3. 两种定义的解释
					* \*pointer[size]----解释:[]优先级高于*,所以pointer是一个size大小的数组,数组元素是指针
					* (*pointer)[szie]----解释:()优先级高于[],所以pointer是一个指针,指向数组
					* 例如: const double * (*(*pd)[3])(const double *,int) = &pa
					* 解释如下: pd是一个指针,指针指向3个元素的数组,数组元素又是函数指针,每个函数指针指向一个返回const double * 的函数

		12. typedef简化和auto标识符
			* typedef double real
			* typedef  const double * (*p_fun)(const double * int)

## 函数探幽

1. 内联函数
	* 内联函数,函数无需跳转到另一个地方执行函数调用,注意,每调用一次都会复制一个内联函数的副本,当调用很多次的时候会占用很多内存,所以,当函数执行花费的时间少于函数调用的开销,那么可以使用内联函数,但是当,函数调用时间小于内联函数的时候,那么节省的时间只占很小的一部分
	* 使用步骤
		1. 使用inline定义或者声明
			* 通常做法是省略原型,将整个定义(函数头和所有函数代码)放在本应该提供原型的地方
			* 内联函数不能递归
			* 内联函数也默认按值传递参数

2. 内联与宏
	* 宏定义只是文本替换,并不是传递参数

3. 引用变量
	* 声明的时候必须初始化,一旦创建,始终效忠于该变量
	* ```c++
	int rat;
    int & rodents = rats;
    int * const pr = &rats;
    ```
    * 上述引用的定义和下面的const指针是等价的
    * 将引用作为函数参数
    * 引用的属性和特别之处
    	1. 当按值传递时,基本类型不用引用和const
    	2. 当结构或者类时,使用const typeName & ra,那么ra将不可改变,其引用的位置也无法改变
    * 临时变量,引用参数和const
    	1. 实参和形参不匹配时,c\+\+将生成临时变量,当前仅当参数为const引用时,c++才允许这样做
    	2. 实参类型正确,但不是左值
    	3. 实参的类型不正确,但是可以转换为正确的类型
    * 左值
    	1. 描述: 左值参数是可被引用的对象----变量,数组元素,结构成员;引用和解除引用的指针都是左值
    	2. 引入const后,常规变量和const变量都可以视为左值,因为可以通过地址访问,但常规变量属于可以修改的左值,而const变量属于不可修改的左值

    * 右值引用
    	1. 此种引用可以指向右值
    	2. 使用&&声明
    	3. 例如 double && rref = std::sqrt(36.00);
    	4. 引入右值引用的目的是:让库设计人员能够提供操作的更有效实现(如移动语义)

    * 非左值
    	1. 描述: 非左值包括字面常量(用引号括起来的字符串除外,他们由其地址表示)和包含多项的表达式

    * 尽可能使用const
    	1. 使用const可以避免无意中修改数据的编程错误
    	2. 使用const是函数能够处理const和非const实参,否则只能接受非const数据
    	3. 使用const引用使函数能够正确生成并使用临时变量

    * 返回引用与返回结构
    	1. 返回引用是直接返回内部的引用
    	2. 返回结构是返回内部结构的拷贝
    	3. 相比较来看,返回结构的时候,会先拷贝结果再将结果赋值,但是返回结构引用,会直接返回并将结果赋值,不会产生额外的拷贝,因为返回的是引用,那么必然被引用的已经存在了,外部可以直接访问到被引用的变量

	* 对象继承和引用
		1. 形参为基类对象的引用,传参可以传基类对象或者子类对象

4. 默认参数
	* 为某个函数原型添加默认参数值,必须从右往左,设置默认值,如果某个参数要设置默认值,那么他右边的必须都设置了默认参数才可以,实参按从左往右的方式赋值给形参
	* 只有函数原型需要指定默认参数值,函数定义与没有默认参数时完全相同

5. 函数重载(函数多态)
	* 编译器在检查函数特征标(参数类型)时,将把类型引用和类型本身视为同一个特征标
	* 匹配函数的时候并不区分const和非const变量

6. 函数模板
	* 显示具体化(explicit specialization),其中包含所需代码,当编译器找到与函数调用匹配的具体化定义的时候,使用该定义,不再使用模板
	* 模板原型
		```c++
		template< typename T >
        void function(T&,T&);
        ```
    * 显示具体化
    	```c++
        template<>void function<具体类型>(具体类型&,具体类型&);
        //或者
        template<>void function(具体类型&,具体类型&);
        因为参数列表已经指明了具体类型
        ```
    * 在编译器选择原型时--非模板版本>显示具体化>模板版本
    * 实例化和具体化
    	1. 实例化
    		* 隐式实例化:使用函数模板并不是函数定义,但使用具体类型的模板实例就是函数定义,这种实例化方式称为隐式实例化
    		* 显示实例化:指定使用某一模板在编译的时候生成一个实例化函数定义，如:```c++
	template void swap<具体类型>(具体类型,具体类型);
    ```
    上述声明代表,将使用swap模板生成一个使用int类型的实例,也就是使用swap()模板生成int类型的函数定义
    	2. 显示具体化代表,不要使用swap()模板来生成函数,而应该使用专门为int类型显示定义的函数定义,该原型必须有自己的函数定义,而不是使用模板的定义,template关键字后面有<>,显示实例化没有
	* decltype关键字
		1. 使用方法:
		```c++
        int x;
        decltype(x)y;	//令y与x的类型一样,y可以是一个赋值表达式,x也可以是一个赋值表达式
        ```
        2. decltype的实现
        	* 为确定类型,编译器必须遍历一个核对表,decltype(expression) var;
        		1. 当expression是一个没有用括号括起来的标识符,则var的类型与该标识符的类型相同,包括限定符const等
        		2. 当expression是一个函数调用,则var的类型与函数的返回类型相同,但是并不会调用函数,编译器通过查看函数的原型来获取返回类型,无需实际调用函数
				3. 当expression是用括号括起来的，且是左值的时候,var的类型为指向括号内部左值类型的引用
				4. 上述条件都不满足的时候，var的类型与expression相同
				5. 可以结合typedef使用decltype

		3. decltype用于函数声明
			* 用auto实现返回类型后置
			* 例如
			```c++
            template< class T1,class T2 >
            auto gt(T1 x,T2 y)->decltype(x+y){
            return x+y;
            }
            ```

## 内存模型和名称空间

1. 链接性
	* 外部链接性: 可以被其他文件共享
		1. 全局变量默认为外部链接的
		2. extern typename Name = val; || typeName name = val;
		3. 在文件中使用其他文件的外部链接的变量,需要使用外部变量声明extern typeName name; name与其他文件的同名
	* 内部链接性: 只可以在文件内部共享
	* 无链接性: 只可在代码块共享

2. cv限定符
	* c----const
		1. 在c++中const限定符对默认存储类型稍有影响,在默认情况下全局变量的链接性为外部链接,但const全局变量的链接性为内部,也就是说在c++看来,全局const定义如同使用了static一样
		2. c++修改了常量类型的规则,加入将一组常量放在头文件中,并在同一个程序的多个文件中使用该头文件,那么预处理器将头文件的内容包含到每个源文件中后,所有的源文件都包含常量的定义,如果const声明的链接性是外部的话,将出现单定义冲突,殉
	* v----volatile
		1. 编译器发现,程序在几条语句中两次使用某个变量,则编译器可能不是让程序查找这个值两次,而是将这个值缓存到寄存器中,这种优化假设变量的值在这两次使用之间不会发生改变,如果不将变量声明成volatile则编译器将进行这种优化,将变量声明成volatile相当于告诉编译器不要进行这种优化

3. mutable
	* 可以用他指定，即使结构(或类)变量为const,其某个成员也可以被修改
	* 结构或者类加上const后内部也不能修改,但是加上mutable则该成员能修改

4. 函数链接性
	* 默认情况下,函数具有外部链接性,即可以在文件间共享,实际上可以在函数原型中使用关键字extern指出函数是在另一文件中定义的

5. 存储方案和动态分配
	* 使用new运算符初始化
		* 内置标量类型:在后面加上括号,括号里面填上初始值,也适用于有合适构造函数的类
			1. int *pi = new int(6);
			2. double * pd = new double(99.99);

        * 使用列表初始化
        	1. 初始化常规数组或者结构
        	2. 初始化单值

	* new失败时,引发异常std::bad_alloc

    * 运算符new和new[]分别调用
    	1. void * operator new(std::size_t)
    	2. void * operator new\[ \](std::size_t)
    * 运算符delete和delete[]
    	1. void operator delete(void *);
    	2. void operator delete\[ \](void *);
	* std::size_t是一个typedef对应合适的整型
	* 定位new运算符(指定要使用的位置)
		1. pointer = new (buffer)name;
		2. pointer = new (buffer) typeName[size];


## 类与对象

1. 内联成员函数,需要在每个使用他们的文件中定义,可以直接将内联定义放在类头文件中,就不用多次实现等价于直接在类中定义函数

2. 构造函数
	* 默认构造:在未提供显示初始值时,用来创建对象
		1. 当且仅当没有提供任何构造函数时,编译器才会提供默认构造函数,如果为类提供了构造函数,那么也必须为其提供默认构造函数,否则不显式提供初始值时将会出错
		2. 默认构造的两种形式
			* 给已有构造函数的所有参数提供默认值(在参数列表中提供=value)
			* 使用函数重载定义另一个构造函数(无参构造),通常在此构造里面提供初始值
			* 不要同时采用上述两种构造
3. 析构函数
	* 如果构造函数使用new分配内存,那么析构要用delete释放
	* 析构函数的调用时机
		1. 静态存储对象:程序结束时调用析构
		2. 自动存储类对象:程序执行完代码块时
		3. 通过new创建: 驻留在栈内存或者自由存储区,使用delete时将调用析构函数
	* 如果程序员未提供析构函数,编译器将提供

4. 赋值
	* 默认情况下,用一个对象给另一个对象赋值会将原对象的成员复制给另一个

5. 列表初始化: 只要有符合的构造函数,也可以使用列表初始化

6. const成员函数
	* returnType function() const
	* 上述定义被成为const成员函数,只要类方法目的不修改调用对象,就应将其声明为const

7. this指针
	* this为指向当前对象的指针
	* 当返回值是引用的时候,返回的不是this指针,而是指针指向的内容

8. 对象数组

9. 类作用域
	* 在类声明不可以定义和初始化静态常量(因为声明还没有分配空间,并不能定义)
	* 解决方案
		1. 使用枚举--枚举并没有创建类数据成员,所有对象中都不包含枚举
		2. 使用static const---此种类型的静态常量将被所有对象共享

10. 运算符重载
	* operator关键字
	* 将要重载的运算符放入operator后面,即operator运算符(操作数)
	* operator运算符(操作数)也是由当前对象调用的,运算符右边的对象会被作为参数
	* 即运算符左边是调用对象,右边是作为参数被传递的对象
	* 重载限制
		1. 重载后的运算符必须至少有一个操作数是用户定义的类型,防止用户为标准类型重载运算符
		2. 使用运算符的时候不能违反运算符原来的句法规则
		3. 不能修改运算符的优先级
		4. 不能创建新运算符
		5. 不能重载的运算符
			* sizeof
			* .
			* \*
			* ::
			* ?:
			* typeid:一个RTTI运算符
			* const_cast:强制类型转换
			* dynamic_cast:强制类型转换
			* reinterpret_cast:强制类型转换
			* static_cast:强制类型转换
		6. 大多数运算符可以通过成员或者非成员函数(不是由对象调用,使用的所有制都是显式参数,每个操作数都是参数,而不是某一个操作数对象调用方法)进行重载,但下面的运算符只能通过成员函数重载
			* =:赋值运算符
			* ():函数调用运算符
			* []:下标运算符
			* ->:通过指针访问类成员的运算符
11. 友元
	* 友元函数
	* 友元类
	* 友元成员函数
	* 友元创建步骤
		1. 在类声明内部放入其原型,记得在原型声明前加上friend
		2. friend意味着该函数原型虽然在类声明中声明,但是其并不是成员函数
		3. 虽然该函数不是成员函数,但是拥有与成员函数同样的权限
		4. 在定义实现的时候不需要加friend
		5. 可以使用友元+成员函数重载来完成操作数顺序变换实现同样的效果
	* 常用友元
		1. <<
			* case1: 使用cout<<对象,来打印,如果是成员函数运算符重载的化,对象将会在<<前面,所以使用友元
			* case2: 另一个ostream对象是cerr,将输出发送到标准输出流--默认显示器,但在UNIX,Linux和windows命令行环境中,可以重定向到文件,又ofstream继承ostream，那么可以使用重载<<实现将数据写入到文件和屏幕上,只需要传递ofstream对象
			* case3: 实现连续<<可以使得友元函数返回ostream的引用,也就是传参的ostream对象

12. 重载运算符作为成员函数还是非成员
	* 除特殊的只能册作为成员函数重载的运算符外,其他使用友元更好,尤其是为类定义类型转换的时候

13. 类的自动转换和强制类型转换
	* 接受一个参数的构造函数实现参数类型的值转换为该类的对象
		1. 程序将使用构造函数来创建一个临时对象,然后将后面的值为初始值,然后采用逐成员赋值方式将临时对象的内容复制到目标对象中,这一过程称为隐式转换,自动进行,不需要强制转换
		2. 可以使用关键字explicit关闭该特性
		3. 使用了explicit过后只有一个参数的构造函数将用于显式强制类型转换,否则可能用于隐式类型转换
		4. 隐式转换的几种情况
			* 将类对象初始化为参数类型的值时
			* 将参数类型的值赋值给对象时
			* 将参数类型的值传递给接受类对象参数的函数时
			* 返回值被声明为对类的函数返回参数类型值时
			* 在上述任意一种情况下使用可以转换为参数类型的内置类型时
14. 转换函数
	* 上述指明可以将内置类型转换为类对象,可以做相反转换吗
	* 答案是可以,但是不是使用构造函数,构造函数只用于某种类类型到类类型的转换,要进行相反的转换必须使用特殊的c++运算符--转换函数
	* 转换函数是用户定义的强制类型转换,可以像使用强制类型转换那样使用它们,也可以直接让编译器决定如何做
	* 如何定义转换函数
		1. 转换函数必须是类方法
		2. 转换函数不能指定返回类型
		3. 转换函数不能有参数
		4. 例如转换为double类型的原型如下
			* operator double();
			* 无需指定返回类型

15. 转换函数和友元函数


## 类和动态内存分配

1. 静态数据成员
	* 普通静态数据成员不能在类声明头文件中初始化,需要在类定义文件中初始化
	* 枚举或者const静态成员可以直接在类声明中初始化

2. c++自动提供下面的成员函数
	* 默认构造函数,如果没有定义构造函数
	* 默认析构函数,如果没有定义
	* 复制构造函数,如果没有定义
		1. 何时调用: 新建一个对象并初始化为同类现有对象时,复制构造函数将被调用，当函数按值传递对象(进入函数时生成临时对象,生成临时对象的时候需要调用复制构造函数)或函数返回对象的时候都将使用复制构造函数
		2. 默认的复制构造函数功能:默认复制构造函数逐个复制非静态成员(成员复制也称为浅复制)复制的时成员的值（特别注意指针）
		3. 定义一个显式复制构造函数(深复制)
			* 特别对于指针来说,需要复制指针指向地址的内容,并复制给新对象的成员
	* 赋值运算符,如果没有定义
		1. 接受并返回一个指向类对象的引用
		2. 使用时机
			* 将已有对象赋给另一个对象的时候
			* 赋值运算符的隐式实现对成员逐个复制,如果成员本身就是类对象,则程序将使用为这个类定义的赋值运算符来复制该成员(赋值嵌套),但静态数据成员不受影响
	* 地址运算符,如果没有定义
	* 移动构造函数
	* 移动赋值运算符
	* 编译器将生成上述最后三个函数定义,如果使

3. 有关返回对象的说明
	* 返回指向const对象的引用
	* 返回指向非const对象的引用
		* 常见两种返回非const对象的引用
			1. 重载赋值运算符
			2. 重载起与cout一起使用的<<运算符
			3. 赋值运算符可用于连续赋值情况
			4. <<返回值用于串接输出
	* 返回对象
		1. 如果返回的对象时被调用函数中的局部变量,则不应该按引用的方式返回他,因为在被调用函数执行完毕的时候,局部对象将调用其析构函数
	* 返回const对象

4. 使用指向对象的指针
	* 使用new初始化对象
		1. 将调用对应的构造函数
		2. 若new后面没有参数,那么将调用默认构造函数
		3. new只是给类成员分配内存,构造函数才为成员指向的位置分配内存
	* delete一个对象的时候只会释放成员本身占的内存,不会释放成员指向的内存,这部分内存需要在析构函数释放,当然会自动调用析构

5. 使用带定位的new
	* 	如果不指定位置的话,两次在同一块内存创建对象,都会从块内存初始位置开始存放对象,在存放两个连续对象的时候,最好第二个在初始位置上偏移一个对象的位置
	* delete不能与带定位的new配合使用(不能保证析构被调用,而且对象地址可能和内存块地址相同delete会导致二义)
	* 显式调用析构函数再delete块内存

6. c++11类内初始化
	* 与在构造函数中使用成员初始化列表等价


## 类继承

1. 派生类继承的内容
	* 继承基类的私有成员,但是不能直接访问
	* 继承公有成员,且作为公有成员被继承

2. 派生类中需要添加的内容
	* 自己的构造函数
	* 根据需要添加额外的数据成员和成员函数

3. 权限问题
	* 派生类不能直接访问基类的私有成员,而必须通过基类方法进行访问,也就是说,派生类的构造函数可能调用从基类继承而来的方法,来修改从基类继承的数据成员的值
	* 创建派生类对象的时候,首先创建基类对象,意味着基类对象应当在进入派生类构造函数之前被创建,c++使初始化列表语法来完成这种工作,显式调用基类构造函数

4. 派生类和基类之间的特殊关系
	* 派生类对象可以使用基类的非私有方法
	* 基类指针可以在不进行显式转换的情况下指向派生类对象
	* 基类引用可以在不进行显式转换的情况下引用派生类对象
	* 基类指针或引用只能用于调用基类的方法
	* 不可以将基类对象和地址赋给派生类引用和指针

5. 继承关系
	* has-a
	* is-a
	* is-implemented-as-a
	* uses-a

6. 多态公有继承
	* 多态: 希望同一个方法在派生类和基类中的行为是不同的,方法的行为取决于调用该方法的对象
		1. 在派生类重新定义基类方法()
		2. 使用虚方法
	* virtual关键字 : 使用了虚关键字后程序在根据引用和指针选择方法版本的时候,不是根据指针或者引用的类型选择方法版本,而是通过指针指向的位置的对象的类型选择方法版本
		1. 在基类中声明派生类需要重新定义的方法时,最好加上virtual关键字,特别是析构函数,析构函数必加
	* 虚成员函数和动态联编
		1. 若成员方法未声明成虚方法则就是静态联编
		2. 若成员方法声明成虚方法编译器使用动态联编
	* 虚函数工作原理
		1. 给每个对象添加一个隐藏成员,隐藏成员中保存了一个指向函数地址数组(虚函数表(virtual function table,vtbl))的指针
		2. vtbl保存函数原始版本的地址,
		3. 调用函数的时候,去查找当前对象的vtbl表,然后调用指定函数
	* 虚函数使用成本
		1. 每个对象将增大,多出一个指向虚函数表的指针
		2. 对于每个类,编译器需要创建一个虚函数地址表
		3. 对于每个函数调用,需要执行额外的查找操作

7. 虚函数注意事项
	* 构造函数不能是虚函数
		1. 创建派生类的时候将调用派生类构造函数,而不是基类的构造函数,然后基派生类的构造函数将使用基类的一个构造函数,派生类不能继承基类的构造函数
	* 析构函数
		* 析构函数应当是虚函数,除非类不用做基类
	* 友元函数
		* 友元不能为虚函数,因为友元不是类成员,只有成员才能是虚函数,如果有特殊的需求,可以使用友元+虚成员函数解决
	* 没有重新定义
		* 如果派生类没有重新定义函数,那么将使用该函数的基类版本,如果派生类位于派生链中,则将使用最新的虚函数版本
	* 重新定义将隐藏方法
		* 在派生类中重新定义方法并不是重载而会覆盖声明

8. 访问控制
	* protected
		1. 派生类的成员可以直接访问基类中的保护成员,但是不能直接访问私有成员

9. 抽象基类
	* c++通过使用纯虚函数提供未实现的函数,纯虚函数声明的结尾出为=0
	* 当类中包含纯虚函数的时候,则不能创建该对象,只能用作基类

10. 继承和动态内存分配
	* 派生类不再使用new



## c++代码重用

1. 重温explicit用法

2. 初始化顺序,初始化列表包含多个项目的时候，初始化顺序为他们在类里面的声明顺序

3. 多重继承

4. 使用包含还是继承(has-a关系)

5. 公有继承
	* 基类的公有方法将成为派生类的公有方法

6. 私有继承
	* 私有继承时,基类的公有成员和保护成员都将成为派生类中的私有成员,这意味着基类方法将不会成为派生类对象共有接口的一部分,但是可以在派生类的成员函数中使用
	* 派生类私有继承基类过后,派生类将拥有一个基类的组件(相当于拥有一个基类的成员对象),派生类的方法可以使用基类的方法来修访问基类组件
	* 私有继承将未命名的基类对象添加到类中
	* 私有继承构造函数使用列表初始化的时候使用类名而不是成员们来标识构造函数
	* 访问基类方法
		1. 只能在派生类中使用基类的方法
	* 访问基类对象
		1. 因为私有继承的时候没有显式的对象名字,使用强制类型转换,将继承的对象强制转换为基类对象,可以返回一个强制转换的引用,避免生成对象
	* 访问基类友元函数
		1. 将对象显式转换为基类，即使是公有继承也要使用这种方法

7. 保护继承
	* 保护继承的时,基类的公有成员和保护成员都将成为派生类的保护成员,和私有继承一样,基类的接口在派生类中也可用,但在继承层次结构之外不可用

8. 使用using重新定义访问权限
	* 保护继承或者私有继承的时候,基类的公有成员将会变成保护成员和私有成员,假设让基类的方法在派生类外面可用，方法之一是定义一个使用该基类方法的派生类方法,然后在方法内部调用基类方法,还可以使用using权限,使用using的时候后面方法不用加()

9. 多重继承
	* 虚基类
		1. 虚基类使得从多个类(他们的基类相同)派生出的对象只继承一个虚基类对象,在类声明中使用关键字virtual,可以是基类被用作子类的虚基类(virtual和public的次序无关紧要)

10. 类模板
	* 默认类型模板参数
		1. 为参数类型提供默认值
		2. 在实例化的时候若没有,提供该类型的值,那么将会用默认值来生成

11. 模板具体化
	* 隐式实例化
		1. 编译器在需要对象之前不会生成类的隐式实例化(实例化对象(为对象分配内存的时候才会导致编译器生成类定义)
	* 显式实例化
		1. 当使用关键字template并指出所需类型来声明类时,编译器将生成类声明的显式实例化,声明必须位于模板定义所在的名称空间
	* 显式具体化
		1. 显式具体化是特定类型(用于替换模板中的泛型)的定义,有时候可能需要在为特殊类型实例化的时候,对模板进行修改,使其行为不同(针对不同的类型(特殊类型)定义的不同的行为,而不是用通用的泛型模板来实例化)
		2. 格式如下:
			* template<>class Classname<具体类型名字>{}
	* 部分具体化
		1. 部分限制模板的通用性,例如部分具体化可以给类型参数之一指定具体类型
			* 格式: template < class T1 > class Pair < T1, int >{ }\;
			* tmeplate后面的<>是没有被具体化的泛型,如果<>为空将导致显式具体化
		2. 如果有多个模板可以选择,编译器将使用具体化程度最高的模板
		3. 可以通过为指针提供特殊版本来部分具体化现有模板
			* 如果在<>里面不是指针的类型,那么使用通用模板
			* 如果在<>里面是指针类型,那么使用指针具体化版本

12. 成员模板
	* 将模板类和模板函数作为某个模板类的成员

13. 将模板作为参数
	* 模板可以包含类型参数(typename T)和非类型参数(int n),模板还可以包含本身就是模板的参数,用于实现STL
	* 格式 template < template < typename T > class Name>
	* 显然在实例化时<>里面的参数也要为一个模板类
	* 在类声明的内部,对模板参数实例化

14. 模板类和友元
	* 非模板友元
		1. 在模板类声明中将一个常规函数声明为友元
		2. 该函数将成为用该模板实例化的所有类的友元
		3. 此种友元函数不提供对象参数(类没实例化,没办法提供对象参数)
			* 访问全局对象(可以使用全局指针访问非全局对象)
			* 创建自己的对象
			* 访问独立于对象的模板类的静态数据成员
	* 约束模板友元,友元的类型取决于类被实例化时的类型
		1. 首先,在类定义的前面声明每个模板函数
		2. 然后再次将模板声明为友元,这些语句根据类模板参数的类型声明具体化
		3. 格式
		```c++
        template < typename T > void counts();
        template< tpename T > void report(T &);
        template< typename TT>
        class HasFriendT{
        friend void counts< TT >();
        friend void report<>(HasFriendT< TT > &)
        };
        ```
	* 非约束模板友元,即友元的所有具体化都是类的每一个具体化的友元
		1. 例子
			```c++
            template< typename T >
            class ManyFriend{
            template < typename C,typename D> friend void show(C&,D&);
            };
            ```
15. 模板别名(c++11)
	* using =
		1. 用于非模板: 与typedef等价
		2. 用于模板直接当模板使用


## 友元、异常和其他

1. 友元类
	* 将一个类定义为某个类的友元类，那么该类的所有函数都可以访问原类私有成员和保护成员
	* 友元类声明可以位于公有,私有或保护部分,所在位置无关紧要
2. 友元成员函数
	* 让某个类的某一个函数成为另一个类的友元
		1. 在目标类中将该函数声明为友元函数(使用类::方法,作用域运算符)
		2. 要完成上述语句,就需要拥有友元函数的定义需要在目标类之前
		3. 但是会造成循环依赖,那么需要使用前向声明,在拥有友元函数的类之前声明目标类
	* 其他友元关系
		1. 彼此成为对方的友元
			* 需要使用前向声明
			* 使用某一个类对象的类友元方法,其原型可以在目标类声明之前声明,但是必须在目标类声明之后定义
			* 在外部使用内联定义
		2. 共同的友元
			* 某个函数是几个类的友元
			* 重载就行

3. 嵌套类

4. 异常
	* abort()向标准错误流发送消息(程序异常终止),然后终止程序,返回一个随实现不同的值,告诉OS(如果程序由另一个程序调用,告诉父进程)处理失败,abort()是否刷新文件缓冲区(用于存储读写到文件中的数据的内存区域)取决于实现
	* exit()刷新文件缓冲区,不显示消息

5. 异常机制
	* 异常类型
		1. 将对象用作异常类型
		2. 捕获的时候捕获的是对象引用
	* 引发异常(throw)
		1. 通常throw的为类类型
	* 使用处理程序捕获异常(catch)
		1. 如果函数引发了异常,而没有try块或没有匹配处理的程序时,默认情况下,程序最终将调用abort()函数,但可以修改这种行为
	* 使用try块

6. 异常规范
	* c++11 --- noexcept关键字,函数不会引发异常

7. 栈解退
	* 假设try块没有直接调用引发异常的函数,而是调用了对引发异常的函数进行调用的函数,则程序流程将从引发异常的函数跳到包含try块可处理程序的函数,其中涉及到栈退解
	* 普通函数调用完成时，程序流程将跳到该函数被调用时存储的地址,同时栈顶的元素被释放,因此函数通常都返回到调用他的函数,同时每个函数在结束时释放其自动变量,如果自动变量是类对象,则类的析构函数将被调用
	* 假设函数由于异常而终止,则程序也将释放栈中的内存,但不会在释放栈的第一个返回地址后停止,而是继续释放栈,直到找到一个位于try块中的返回地址,随后控制权将转到块尾的异常处理程序,而不是函数调用后面的下一条语句,此过程称为栈解退

8. 其他异常特性
	* 引发异常的时候,throw总是创建一个临时拷贝,即使异常规范和catch中指定的是引用,任仍然是拷贝,好处为----引发异常的函数执行完毕后,原来的对象将不复存在
	* 为什么catch中是引用的时候也是拷贝对象,还要用引用?
		1. 因为如果异常类型有继承关系,那么只要在异常规范中列出一个基类引用将与任何派生类对象匹配
		2. 但是也要注意,如果将基类捕获放在最上面,那么后面的派生异常将不会被捕获到

9. exception类
	* 可以当自定义异常类的基类,其中有虚函数what

10. stdexcept异常类
	* loginc_error
		1. 描述了典型的逻辑错误,总体而言通过合理的编程可以避免这种错误,实际上错误还是有可能发生
		2. domain_error
		3. invalid_argument
		4. length_error
		5. out_of_bounds
	* runtime_error
		1. 描述在运行期间可能发生的但难以预计和防范的错误
		2. range_error
		3. overflow_error
		4. underflow_error
	* bad_alloc异常和new
		1. c++中new分配内存失败的时候将会引发bad_alloc错误
		2. 用户可以关闭这种特性,不让其抛出异常,使用nwe (std::nothrow)来关闭异常的抛出,此时若分配失败将会返回空指针(0)

11. 异常,类,和继承

12. 异常什么时候会迷失方向
	* 如果在带异常规范的函数中引发,则必须与规范列表中的某种异常匹配(在继承层次结构中,类类型与这个类及派生类对象匹配),否则为意外异常,
	* 如果异常不是在函数中引发的(函数没有异常规范),则必须捕获,如果没有捕获(没有,try,catch)则异常称为未捕获异常,默认情况下将导致程序异常终止

## RTTI(Runtime Type Identification)运行阶段类型识别

- 适用场景
	1. 在派生场景的时候,可以让基类指针指向其中任何一个派生类对象，这样该指针可以调用:在处理一些信息后,选择一个类,并创建这种类型的对象,然后返回他的地址,而该地址可赋值给基类指针,RTTI可以完成对象类型的确定

- 工作原理
	1. 如果可能的话dynamic_cast运算符将使用一个指向基类的指针来生成一个指向派生类的指针,否则该运算符返回0---空指针
		* dynamic_cast并不能回答指针指向的是哪个对象,这样的问题,但可以回答,是否可以安全地将对象的地址赋给特定类型的指针
		* 通常,如果指向的对象(*pt)的类型为Type或者是从Type直接或间接派生而来的类型,则下面的表达式将指针pt转换为Type类型的指针
		> ```c++
        	dynamic_cast < Type* >(pt);
        	```
        > 否则结果为0,即空指针
        > 出现三个类,连续继承的情况,基类指针需要调用中间基类和底层派生类才有的函数时候,必然出错,但是此时可以使用dynamic_cast来将其安全转换为中间基类,如果转换不成功,将会返回空指针
	2. typeid运算符返回一个指出对象的类型的值
		* 能够确定两个对象是否为同种类型
		* 与sizeof相似,可以接受两种参数---类名,结果为对象的表达式
		* typeid返回一个对type_info对象的引用,其中type_info是在头文件typeinfo中定义的一个类,type_info重载了==和!=运算符,以便可以使用这些运算符来对类型进行比较,可以做如下比较 typeid(类名) == typeid(*pd"指向某种对象的指针")
		* 如果typeid对空指针使用,将会引发bad_typeid异常
	3. type_info结构存储了有关特定类型的信息

- 注意事项
	* 只能将RTTI用于包含虚函数的类层次结构,只有对于这种类层次结构,才应该将派生类对象的地址赋值给基类指针
	* 即使编辑器支持RTTI,在默认情况下,他也可能关闭该特性,如果该特性被关闭,程序仍然可能通过编译,但是将出现运行阶段错误,在这种情况,查看文档或菜单选项
	* 应尽可能使用虚函数,只在必要的时候使用RTTI
	* 可以将RTTI用于引用,用法有点不同
		1. 没有与空指针对应的引用值,所以没办法用特使引用值来表示失败
		2. 当转换失败时候将会引发bad_cast异常
		3. 所以在对引用使用RTTI的时候,引入异常捕获
	* 正确使用RTTI


## 类型转换运算符

1. dynamic_cast
	* 前面已经描述
2. const_cast
	* 改变值为const或者volatile
	* const_cast < target_type_name >(expression)
	* 这个转换只能将原来的类型进行const或者volatile的转换,不可以进行类型的转换
	* 通用类型转换也可以完成去const的转换或者加上const的转换,但是在此过程中可能改变类型
	* const_cast能删除const指针的中的const,但是不一定能删除const本身的值
3. static_cast
	* static_cast < target_type_name > (expression)
	* 当且仅当,type-name可被隐式转换expression所属的类型或者expression可被隐式转换为type-name所属类型时,该转换才合法
4. reinterpret_cast


## 智能指针模板类
1. 包含memory头文件
2. 使用语法
	* auto_ptr < type > name(new type);
	* shared_prt< type > name(new type);
	* unique_ptr< type > name(new type);
	* 每种智能指针都拥有同一个构造函数而且关闭了隐式转换构造,不能隐式赋值
3. 智能指针只能用于堆区内存,不可以用于栈区内存,所以给构造传引用是错误的
4. unique_ptr
	 * 拥有所有权概念,对于特定的对象,只有一个智能指针可拥有,这样只有一个智能指针对象能删除该内存区域，让赋值操作转让所有权
	 * 与auto_ptr相比,unique_ptr会禁止将会存在一段时间的原指针赋值给另一个unique_ptr,防止留下悬挂指针
	 * 但是如果源指针是个临时右值(赋值给别人后自己生命周期结束),unique_ptr会允许
	 * 如果非要完成上述赋值,那么可以使用c++标准库函数move(origin_unique_ptr)
	 * auto_ptr和shared_ptr不可以使用new []
	 * 但是unique_ptr可以使用
	 * 当unique_ptr为右值的时候,可以赋值给shared_ptr

5. shared_ptr
	* 创建引用计数,赋值时引用计数加一,当且仅当最后一个指针过期的时候才调用delete


## STL
1. 迭代器
	* 标准声明 容器名字 < 实例类型 > ::iterator name; 可以使用auto自动推断
	* 迭代器可以使用解除引用等操作,操作类似指针
	* 对迭代器执行++与指针类似,将会指向下一个容器中元素

2. vector
	* push_back() : 动态管理内存
	* erase(iterator 1, iterator 2) : 删除区间内元素,第一个参数为删除的起始处,第二个为删除的终点的后一个元素迭代器对象
	* insert(iterator1,iterator2,iterator3):第一个元素指定插入位置(在当前位置的前面，但是不会占据前一个元素的位置,是额外的插入),第二个元素指定被或者说将要被插入的区间，该区间通常是另一个容器的区间

3. 公用方法
	* for_each(iterator1,iterator2,(void *) ptr_function):前两个参数是遍历区间的迭代器,后面是函数指针(更准确地说是函数对象),即要对区间内的元素的操作
	* random_shuffle(iterator 1,iterator 2),随机排列参数中迭代器区间的元素,此函数要求容器类本身可以随机访问
	* sort(iterator 1, iterator 2) : 默认使用<对区间元素操作,排序,也需要容器类本身支持随机访问
	* sort(iterator 1, iterator 2,自定义排序函数名字):此种排序可能会造成弱排序
4. 迭代器种类
	* 输入迭代器
		1. 从程序的角度来看,即容器信息被视为输入,输入迭代器可用来读取容器中的信息,即输入迭代器解除引用可以得到元素的值,但是不一定能修改，因此需要修改值的将不会使用输入迭代器
		2. 输入迭代器是单向迭代器,只能前进不能倒退,不能保证第二次遍历时顺序不变
	* 输出迭代器
		1. 输出迭代器不能读取容器的值,解除引用只能修改容器的值,其他与输入迭代器类似
	* 正向迭代器
		1. 正向迭代器使用++运算符来遍历容器,然而与输入和输出不同的是,他总是按相同的顺序遍历一系列值
		2. 将正向迭代器递增后，如果前面的迭代对象被保存下来那么仍然可以保证正确读取或者写入
		3. 正向迭代器可以读取和写入,也可以用const来控制写入
	* 双向迭代器
		1. 双向迭代器拥有正向迭代器的所有特性，并且在此基础上可以完成逆向迭代
	* 随机访问迭代器
		1. 拥有双向迭代器所有特性
		2. 增加了支持随机访问的操作(对迭代器增加运算)

5. 函数对象(函数符):可以以函数方式与()结合使用的任意对象
	* 函数名
	* 指向函数的指针
	* 重载了()运算符的类对象 operator() (parameter)
	* c++规定函数符
		1. 生成器:不用参数就可以调用的的函数符
		2. 一元函数:用一个参数可以调用的函数符
		3. 二元函数:用两个参数可以调用的函数符
		4. 返回bool的一元函数是谓词
		5. 返回bool的二元函数是二元谓词

## 输入,输出文件
1. 键盘输入时候，一般按回车刷新输入缓冲
2. 输出是,一般遇到换行符刷新输出缓冲
3. 用于管理流和缓冲的类
	* ios_base:表示流的一般特征
		1. 是否可以读取
		2. 是二进制还是文本流等
	* 基类--ios:拥有一个指向streambuf对象的指针
	* streambuf类用于管理输入输出缓冲区内存
		1. 为缓冲区提供内存
		2. 填充缓冲区
		3. 访问缓冲区
		4. 刷新缓冲区
		5. 管理缓冲区内存
	* ostream:输出类,拥有输出方法,派生于ios
	* istream:输入类,拥有输入方法,派生于ios
	* iostream:从istream和ostream继承输入输出方法,多重继承
	* 在程序中函数文件将自动创建8个函数对象，