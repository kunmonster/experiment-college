# leetcode	note


1. 剑指offer35--复杂链表的复制

2. sword offer 05---replace spacebar(空格)
	* 思路：此题重点在空间复杂度的控制,传参的时候传了一个临时变量，我们可以利用这个临时变量原地修改直接返回这个临时变量
	* 要实现原地修改必须要求string动态可扩充,c++ string 动态扩充直接在尾部插,无需复制空间,虽然空间可能不连续,但是在分配内存的时候会多分配一些。

3. sword offer 58---rotate the first n character to the left(左旋字符串,将前n个字符串移动到末尾,后面的填充上来)
	* 思路: 将整体逆置,再将局部逆置, 注意将前n个字符移动到末尾,那么在局部逆置时候,应该逆置前面length()-n个字符和后n个字符

4. sword offer 03----数组中重复的数字
	* 题目描述: 找出数组中的重复数字(任意一个)
	* 思路:
		1. 利用哈希表或者set(集合)：
			* 哈希表存储元素和个数的键值对

		2. 原地修改数组
			* 因为数组长度为n且,且其中包含的数为0~n-1,因为存在重复，那么将每个数字存放在其对应的索引上的时候,必然会出现该索引上已经存放了该数的情况,此时就能查出重复
			* 当index == arr[index]时候,滑向下一个
			* 当arr[arr[index]] == arr[index]时候,显然是重复了
			* 其他情况的时候,直接交换arr[index]和arr[arr[index]]就可以了,不用变动index,因为变动过后要是相等,在下一次循环的时候就会变成Case1

5. sword offer 53---在排序数组中查找数字
	* 题目描述: 统计一个数字在排序数组中出现的次数
	* 思路:
		1. 由于是升序数组,直接遍历到第一个目标位置和最后一个目标位置,索引相减加一就行,在找第一个位置和最后一个位置时候,可以从两边开始找,就不用找中间的
		2. 二分法找外边界
			*

6. sword 52 --- 0~n-1中缺失的数字
	* 描述: 一个长度为n-1的递增排序数组中的所有数字都是唯一的,并且每个数字都在范围0~n-1范围内,在范围0~n-1内的n个数字中有且仅有一个不在该数组中,请找出这个数字
	* 思路
		1. 数字递增且唯一,只有两种缺失数字的情况
			* 第一种是中间缺失,此时当我们发现索引和值不相同时缺的就是当前索引值
			* 第二种是尾部缺失,此时遍历完发现没有缺失(没有返回)那么必然缺失最后一个,即n-1
		2. 二分法
			* 根据元素有序的性质,当某个索引和值相等时,其前面绝对是不缺元素的，但是当某个索引和其对应的值不相等的时候,前面必然出现缺元素,此时再在前面二分,直到找到那个值

7. 剑指offer04---二维数组中的查找
	* 描述: 在一个n*m的二维数组中,每一行都按照从左到右非递减的顺序排列,每一列都按照从上到下非递减的顺序排列,请完成一个高效的函数,输入上述要求的二维数组和整数,判断数组中是否含有该整数
	* 思路
		1. 直接对每一行二分
			* 时间复杂度O(n*logm)
		2. 直接比较每一行的最后一个位置
			* 若那个位置的数比目标值小,那么此行所有的数都比目标值小,所以跳到下一行
			* 若那个位置的数比目标值大,说明此行前面可能存在相等的数,那么跳到前一列

8. 剑指offer11 旋转数组最小的数字
	* 描述: 把一个数组最开始的若干个元素搬到数组的末尾,我们称之为数组的旋转,参考3;给你一个可能存在重复元素值的数组,他原来是一个升序数组,并按上述情形进行了一次旋转。请返回旋转数组的最小值
	* 思路:
		1. 无论旋转多少次,总是有最大值的下一个就是最小值
			* 直接遍历,当出现下一个比前一个小的时候显然就是最小值
		2. 虽然采取了旋转,但是总是局部单调的(若左边界小于右边界,那么整个左边界到右边界都是有序的),采用二分
			* case1 : 若mid小于右边界,说明mid-right单调递增,当中不可能出现最小值
				* 那么就在左半部分去寻找,令 right = mid;(这里由于mid位置可能是最小值,所以right不能置为mid-1)
			* case2 : 若mid大于右边界,说明mid~right中间必然有断层,最小值必然存在于其中
				* 最小值必然不为mid位置的数,此时将left = mid+1;,在右半部分寻找
			* case3 : mid == right,此时要么当前值不是最大值也不是最小值,将right向后滑动一个,right--,缩小了查找的窗口,最终left即为所求

9. 剑指offer50 --- 第一个只出现一次的字符
	* 描述: 在字符串s中找出第一个只出现一次的字符,如果没有,返回一个单空格。s只包含小写字母
	* 思路:
		1. 打表
			* 只有小写字母,对应97-122,用一个26个元素的数组,存放每个元素出现的次数
			* 再遍历一次,找到出现次数为1的元素
		2. 使用unordered_map < char，bool >
			* 第一次遍历时,筛选掉重复出现的,置tag为false
			* 第二次遍历时,直接找无序哈希表第一个bool为true的即可
		3. 队列
			* 使用队列顺序存放每一个字符以及他们第一次出现的位置,当我们对字符进行遍历的时候
			* case1: 遍历时当前字符不在哈希表中,我们将其与其索引二元组pair < char,index> 入队
			* case2: 遍历时发现当前字符已经在哈希表中则置为false然后出队,查看出队元素是否为单次出现,若不是则让他出去,然后继续出队,直到队首为单次元素,再继续遍历字符串

10. 剑指offer32 --- 从上到下打印二叉树(层序遍历)
	* 思路:
		1. 用队列层序遍历就行了

11. 剑指offer --- 从上到下打印二叉树（2）
	* 描述: 要求每一层输出到一行中
	* 思路:
		1. 使用两个队列,遍历某一层时,其下一层元素就全部入队到另一个队列,输出元素,两个队列交替
			* 当一个队列遍历完成时候,必须判断输出的数组是否为空,为空就不能插入结果数组中
		2. 在层序遍历的基础上,每次遍历该层节点个数的队列元素
			* 在进入循环的时候,统计当前队列元素个数,遍历这些,输出到数组中,在遍历的时候将下一层节点入队,控制遍历个数时候,可以使用倒着减

12. 剑指offer32 --- 从上到下打印二叉树(3)
	* 描述: 之字形打印二叉树,层序的基础上按照左右左右的顺序打印
	* 思路:
		1. 使用两个队列,在打印2的基础上,反转第二个队列的输出序列
		2. 在打印2的第二种思路的基础上,维护一个记标志偶数层的标志
			* case1 : 如果为偶数层,则反转数组,再输出,并将标志置为false
			* case2 : 如果为奇数层,则不反转数组就输出m,将标志置为true

13. 剑指offer 26 --- 树的子结构
	* 描述: 输入两颗树A,B判断B是不是A的子结构(约定空树不是任意一个树的子结构)B是A的子结构,即A中有出现和B相同的结构和节点值
	* 思路:
		1. 递归
			* 找出递归出口
				1. case1: 树B的当前节点为空,说明B已经被遍历完了，肯定出现了子结构
				2. case2: 树B当前节点不为空,树A当前节点为空,必然不可能出现子结构
				3. case3: 树A和B的当前节点都不为空,且两个值不相等,那必然不为其子结构
				4. case4: 树A和B的当前节点不为空,且两个值相等,那当A和B当前节点的左右子树都存在子结构时才为存在子结构
			* 注意,上述出口仅适用于非根节点,根节点需要判断

14. 剑指offer-27 --- 二叉树镜像
	* 描述: 完成一个函数,输入一个二叉树,该函数输出它的镜像
	* 思路:
		1. 递归
			* 一直往下,直到最左节点,其下一层为空,然后开始递归其右兄弟,当两个都递归完了,交换两个指针的内容,注意指针遍历传参的时候指针本身还是形参,如果想交换指针本身,使用二级指针或者指针的引用
			* 自上而下或者自下而上都是可以的,不会影响
		2. 迭代
			* 利用栈
				1. 初始root入栈,然后弹出，并将其左右节点入栈,交换左右节点
				2. 将右节点出栈,再将其左右节点入栈同时交换左右节点,直到原来的右子树交换完毕
				3. 剩下左节点,出栈继续做上述操作
			* 利用队列
				1. 初始root入队,出队,将其左右孩子入队,交换左右孩子
				2. 再出队做上述操作,直到队列为空

15. 剑指offer-28 --- 对称的二叉树
	* 描述: 实现一个函数,用来判断一棵二叉树是不是对称的,如果一颗二叉树和他的镜像一样,那么他是对称的。
	* 思路:
		1. 先获得其镜像,然后看看是否和原来的一样
		2. 直接递归
			* 出口:
				+ 当两个节点都为空的时候,显然他们同时到达空,肯定是对称的
				+ 当两个节点有一个为空,一个不为空的时候,肯定不对称
				+ 当两个节点都不为空,但是值不相等的时候,肯定不对称
				+ 当两个节点都不为空,且值相等,那么此时需要看左节点的左子树和右节点的右子树,和左节点的右子树和右节点的左子树是否为对称的