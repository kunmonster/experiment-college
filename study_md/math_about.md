# 数学相关问题

## 最大公约数Gcd

1. 辗转相除法
	- 步骤
		* 求两个数的最大公约数(a,b)===求a和b的最大公约数,要求a>=b,且a,b都为整数
		* 经证明,a与b的最大公约数与(b,r),r为a%b的值,相同,且他们具有相同的约数,可以一直推广下去,可以用以下代码实现
		* 注意递归出口,当b为0时表明上一层的余数为0,表明小的那个数就已经是最大公约数了,为1时也满足

```C
	int gcd(int a,int b){
    	//递归出口
		if(b == 0)return a;
        return gcd(b,a%b);
	}
```

## 最小公倍数Lcm

1. 一个定理
	- lcm(a,b) = (a * b) /gcd(a,b)


## 素数相关

### 素数判断

1. 朴素方法:
	- 从2开始遍历到需要判断的前一个数,整除需要判断的数,只要出现能整除的就直接判断不是素数

2. 优化版本
	- 原理: 一个数等于其两个算数平方根的乘积,如果一个数在大于算术平方根时有因子,那么小于算术平方根的时候必然有一个因子,所以大于算术平方根的时候可以不用判断,直接判断小于算术平方根的数即可,可以节省时间

```C
	int is_prime(int a) {
  	int mid = sqrt(a);
  	for (int i = 2; i < mid; ++i) {
    	if (a % i == 0) return 1;
  	}
  	return 1;
	}
```

### 素数筛选

#### 埃式筛

1. 原理
	- 在筛选指定范围内的素数的时候,如果我们直接挨个遍历判断,肯定效率低下,但是我们可以使用标记的方法,在遍历的时候,遍历出当前数的倍数,那么其一定是合数,就可以快速把合数筛选出
2. 步骤
   - 维护一个状态数组,isnprime[] , isnprime[i] 如果为0表示i为素数,为1表示i为合数,初始化数组所有元素为0,0,1初始化为合数
 -  开始遍历,遍历范围的平方根的前半部分就行了,

1. 代码实现

```C
void ei_sift(int n) {
  // 状态数组,1表示合数,0表示素数,初始化为素数
  int *isnprime = (int *)malloc(sizeof(int) * n);
  memset(isnprime, 0, sizeof(int) * n);
  // 0,1不是素数
  isnprime[0] = isnprime[1] = 1;
  for (int i = 2; i <= sqrt(n); ++i) {
    if (isnprime[i] == 0) {
      for (int j = i * i; j < n; j += i) {
        isnprime[j] = 1;
      }
    }
  }
  for (int i = 0; i < n; i++) {
    if (isnprime[i] == 0) printf("%d ", i);
  }
  free(isnprime);
  return;
}

```